{"ast":null,"code":"import { __assign, __extends } from 'tslib';\nimport React from 'react';\nimport styled from '@emotion/styled';\nvar Container = styled('div')({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  overflow: 'hidden',\n  userSelect: 'none',\n  touchAction: 'none',\n  cursor: 'move'\n});\nvar mediaStyles = {\n  maxWidth: '100%',\n  maxHeight: '100%',\n  margin: 'auto',\n  position: 'absolute',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  willChange: 'transform'\n}; // @ts-ignore I don't want to duplicate mediaStyles\n\nvar Img = styled('img')(mediaStyles); // @ts-ignore I don't want to duplicate mediaStyles\n\nvar Video = styled('video')(mediaStyles);\nvar lineBorder = '1px solid rgba(255, 255, 255, 0.5)';\nvar cropperLines = {\n  content: '\" \"',\n  boxSizing: 'border-box',\n  position: 'absolute',\n  border: lineBorder\n};\nvar cropperArea = {\n  position: 'absolute',\n  left: '50%',\n  top: '50%',\n  transform: 'translate(-50%, -50%)',\n  border: lineBorder,\n  boxSizing: 'border-box',\n  boxShadow: '0 0 0 9999em',\n  color: 'rgba(0,0,0,0.5)',\n  overflow: 'hidden'\n};\nvar gridLines = {\n  '&::before': __assign(__assign({}, cropperLines), {\n    top: 0,\n    bottom: 0,\n    left: '33.33%',\n    right: '33.33%',\n    borderTop: 0,\n    borderBottom: 0\n  }),\n  '&::after': __assign(__assign({}, cropperLines), {\n    top: '33.33%',\n    bottom: '33.33%',\n    left: 0,\n    right: 0,\n    borderLeft: 0,\n    borderRight: 0\n  })\n};\nvar roundShape = {\n  borderRadius: '50%'\n}; // @ts-ignore styled definition does not accept an empty object as first param, while it actually works\n\nvar CropArea = styled('div')({}, function (_a) {\n  var cropShape = _a.cropShape,\n      showGrid = _a.showGrid;\n  return __assign(__assign({}, function () {\n    switch (cropShape) {\n      case 'round':\n        return __assign(__assign({}, cropperArea), roundShape);\n\n      case 'rect':\n      default:\n        return cropperArea;\n    }\n  }()), showGrid ? gridLines : {});\n});\n/**\r\n * Compute the dimension of the crop area based on media size,\r\n * aspect ratio and optionally rotatation\r\n */\n\nfunction getCropSize(mediaWidth, mediaHeight, aspect, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  var _a = translateSize(mediaWidth, mediaHeight, rotation),\n      width = _a.width,\n      height = _a.height;\n\n  if (mediaWidth >= mediaHeight * aspect && width > mediaHeight * aspect) {\n    return {\n      width: mediaHeight * aspect,\n      height: mediaHeight\n    };\n  }\n\n  if (width > mediaHeight * aspect) {\n    return {\n      width: mediaWidth,\n      height: mediaWidth / aspect\n    };\n  }\n\n  if (width > height * aspect) {\n    return {\n      width: height * aspect,\n      height: height\n    };\n  }\n\n  return {\n    width: width,\n    height: width / aspect\n  };\n}\n/**\r\n * Ensure a new media position stays in the crop area.\r\n */\n\n\nfunction restrictPosition(position, mediaSize, cropSize, zoom, rotation) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  var _a = translateSize(mediaSize.width, mediaSize.height, rotation),\n      width = _a.width,\n      height = _a.height;\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom)\n  };\n}\n\nfunction restrictPositionCoord(position, mediaSize, cropSize, zoom) {\n  var maxPosition = mediaSize * zoom / 2 - cropSize / 2;\n  return Math.min(maxPosition, Math.max(position, -maxPosition));\n}\n\nfunction getDistanceBetweenPoints(pointA, pointB) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2));\n}\n\nfunction getRotationBetweenPoints(pointA, pointB) {\n  return Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI;\n}\n/**\r\n * Compute the output cropped area of the media in percentages and pixels.\r\n * x/y are the top-left coordinates on the src media\r\n */\n\n\nfunction computeCroppedArea(crop, mediaSize, cropSize, aspect, zoom, rotation, restrictPosition) {\n  if (rotation === void 0) {\n    rotation = 0;\n  }\n\n  if (restrictPosition === void 0) {\n    restrictPosition = true;\n  } // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n\n\n  var limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp;\n  var croppedAreaPercentages = {\n    x: limitAreaFn(100, ((mediaSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaSize.width * 100),\n    y: limitAreaFn(100, ((mediaSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaSize.height * 100),\n    width: limitAreaFn(100, cropSize.width / mediaSize.width * 100 / zoom),\n    height: limitAreaFn(100, cropSize.height / mediaSize.height * 100 / zoom)\n  }; // we compute the pixels size naively\n\n  var widthInPixels = Math.round(limitAreaFn(mediaSize.naturalWidth, croppedAreaPercentages.width * mediaSize.naturalWidth / 100));\n  var heightInPixels = Math.round(limitAreaFn(mediaSize.naturalHeight, croppedAreaPercentages.height * mediaSize.naturalHeight / 100));\n  var isImgWiderThanHigh = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect; // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n\n  var sizePixels = isImgWiderThanHigh ? {\n    width: Math.round(heightInPixels * aspect),\n    height: heightInPixels\n  } : {\n    width: widthInPixels,\n    height: Math.round(widthInPixels / aspect)\n  };\n\n  var croppedAreaPixels = __assign(__assign({}, sizePixels), {\n    x: Math.round(limitAreaFn(mediaSize.naturalWidth - sizePixels.width, croppedAreaPercentages.x * mediaSize.naturalWidth / 100)),\n    y: Math.round(limitAreaFn(mediaSize.naturalHeight - sizePixels.height, croppedAreaPercentages.y * mediaSize.naturalHeight / 100))\n  });\n\n  return {\n    croppedAreaPercentages: croppedAreaPercentages,\n    croppedAreaPixels: croppedAreaPixels\n  };\n}\n/**\r\n * Ensure the returned value is between 0 and max\r\n */\n\n\nfunction limitArea(max, value) {\n  return Math.min(max, Math.max(0, value));\n}\n\nfunction noOp(_max, value) {\n  return value;\n}\n/**\r\n * Compute the crop and zoom from the croppedAreaPixels\r\n */\n\n\nfunction getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = mediaSize.width / mediaSize.naturalWidth;\n\n  if (cropSize) {\n    var isHeightMaxSize_1 = cropSize.height > cropSize.width;\n    return isHeightMaxSize_1 ? cropSize.height / mediaZoom / croppedAreaPixels.height : cropSize.width / mediaZoom / croppedAreaPixels.width;\n  }\n\n  var aspect = croppedAreaPixels.width / croppedAreaPixels.height;\n  var isHeightMaxSize = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect;\n  return isHeightMaxSize ? mediaSize.naturalHeight / croppedAreaPixels.height : mediaSize.naturalWidth / croppedAreaPixels.width;\n}\n/**\r\n * Compute the crop and zoom from the croppedAreaPixels\r\n */\n\n\nfunction getInitialCropFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize) {\n  var mediaZoom = mediaSize.width / mediaSize.naturalWidth;\n  var zoom = getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize);\n  var cropZoom = mediaZoom * zoom;\n  var crop = {\n    x: ((mediaSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom\n  };\n  return {\n    crop: crop,\n    zoom: zoom\n  };\n}\n/**\r\n * Return the point that is the center of point a and b\r\n */\n\n\nfunction getCenter(a, b) {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2\n  };\n}\n/**\r\n *\r\n * Returns an x,y point once rotated around xMid,yMid\r\n */\n\n\nfunction rotateAroundMidPoint(x, y, xMid, yMid, degrees) {\n  var cos = Math.cos;\n  var sin = Math.sin;\n  var radian = degrees * Math.PI / 180; // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n\n  var xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid;\n  var yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid;\n  return [xr, yr];\n}\n/**\r\n * Returns the new bounding area of a rotated rectangle.\r\n */\n\n\nfunction translateSize(width, height, rotation) {\n  var centerX = width / 2;\n  var centerY = height / 2;\n  var outerBounds = [rotateAroundMidPoint(0, 0, centerX, centerY, rotation), rotateAroundMidPoint(width, 0, centerX, centerY, rotation), rotateAroundMidPoint(width, height, centerX, centerY, rotation), rotateAroundMidPoint(0, height, centerX, centerY, rotation)];\n  var minX = Math.min.apply(Math, outerBounds.map(function (p) {\n    return p[0];\n  }));\n  var maxX = Math.max.apply(Math, outerBounds.map(function (p) {\n    return p[0];\n  }));\n  var minY = Math.min.apply(Math, outerBounds.map(function (p) {\n    return p[1];\n  }));\n  var maxY = Math.max.apply(Math, outerBounds.map(function (p) {\n    return p[1];\n  }));\n  return {\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\nvar MIN_ZOOM = 1;\nvar MAX_ZOOM = 3;\n\nvar Cropper =\n/** @class */\nfunction (_super) {\n  __extends(Cropper, _super);\n\n  function Cropper() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.imageRef = null;\n    _this.videoRef = null;\n    _this.containerRef = null;\n    _this.containerRect = null;\n    _this.mediaSize = {\n      width: 0,\n      height: 0,\n      naturalWidth: 0,\n      naturalHeight: 0\n    };\n    _this.dragStartPosition = {\n      x: 0,\n      y: 0\n    };\n    _this.dragStartCrop = {\n      x: 0,\n      y: 0\n    };\n    _this.lastPinchDistance = 0;\n    _this.lastPinchRotation = 0;\n    _this.rafDragTimeout = null;\n    _this.rafPinchTimeout = null;\n    _this.wheelTimer = null;\n    _this.state = {\n      cropSize: null,\n      hasWheelJustStarted: false\n    }; // this is to prevent Safari on iOS >= 10 to zoom the page\n\n    _this.preventZoomSafari = function (e) {\n      return e.preventDefault();\n    };\n\n    _this.cleanEvents = function () {\n      document.removeEventListener('mousemove', _this.onMouseMove);\n      document.removeEventListener('mouseup', _this.onDragStopped);\n      document.removeEventListener('touchmove', _this.onTouchMove);\n      document.removeEventListener('touchend', _this.onDragStopped);\n    };\n\n    _this.onMediaLoad = function () {\n      _this.computeSizes();\n\n      _this.emitCropData();\n\n      _this.setInitialCrop();\n\n      if (_this.props.onMediaLoaded) {\n        _this.props.onMediaLoaded(_this.mediaSize);\n      }\n    };\n\n    _this.setInitialCrop = function () {\n      var _a = _this.props,\n          initialCroppedAreaPixels = _a.initialCroppedAreaPixels,\n          cropSize = _a.cropSize;\n\n      if (!initialCroppedAreaPixels) {\n        return;\n      }\n\n      var _b = getInitialCropFromCroppedAreaPixels(initialCroppedAreaPixels, _this.mediaSize, cropSize),\n          crop = _b.crop,\n          zoom = _b.zoom;\n\n      _this.props.onCropChange(crop);\n\n      _this.props.onZoomChange && _this.props.onZoomChange(zoom);\n    };\n\n    _this.computeSizes = function () {\n      var _a, _b, _c, _d;\n\n      var mediaRef = _this.imageRef || _this.videoRef;\n\n      if (mediaRef) {\n        _this.mediaSize = {\n          width: mediaRef.offsetWidth,\n          height: mediaRef.offsetHeight,\n          naturalWidth: ((_a = _this.imageRef) === null || _a === void 0 ? void 0 : _a.naturalWidth) || ((_b = _this.videoRef) === null || _b === void 0 ? void 0 : _b.videoWidth) || 0,\n          naturalHeight: ((_c = _this.imageRef) === null || _c === void 0 ? void 0 : _c.naturalHeight) || ((_d = _this.videoRef) === null || _d === void 0 ? void 0 : _d.videoHeight) || 0\n        };\n        var cropSize = _this.props.cropSize ? _this.props.cropSize : getCropSize(mediaRef.offsetWidth, mediaRef.offsetHeight, _this.props.aspect, _this.props.rotation);\n\n        _this.setState({\n          cropSize: cropSize\n        }, _this.recomputeCropPosition);\n      }\n\n      if (_this.containerRef) {\n        _this.containerRect = _this.containerRef.getBoundingClientRect();\n      }\n    };\n\n    _this.onMouseDown = function (e) {\n      e.preventDefault();\n      document.addEventListener('mousemove', _this.onMouseMove);\n      document.addEventListener('mouseup', _this.onDragStopped);\n\n      _this.onDragStart(Cropper.getMousePoint(e));\n    };\n\n    _this.onMouseMove = function (e) {\n      return _this.onDrag(Cropper.getMousePoint(e));\n    };\n\n    _this.onTouchStart = function (e) {\n      e.preventDefault();\n      document.addEventListener('touchmove', _this.onTouchMove, {\n        passive: false\n      }); // iOS 11 now defaults to passive: true\n\n      document.addEventListener('touchend', _this.onDragStopped);\n\n      if (e.touches.length === 2) {\n        _this.onPinchStart(e);\n      } else if (e.touches.length === 1) {\n        _this.onDragStart(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onTouchMove = function (e) {\n      // Prevent whole page from scrolling on iOS.\n      e.preventDefault();\n\n      if (e.touches.length === 2) {\n        _this.onPinchMove(e);\n      } else if (e.touches.length === 1) {\n        _this.onDrag(Cropper.getTouchPoint(e.touches[0]));\n      }\n    };\n\n    _this.onDragStart = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      var _b, _c;\n\n      _this.dragStartPosition = {\n        x: x,\n        y: y\n      };\n      _this.dragStartCrop = __assign({}, _this.props.crop);\n      (_c = (_b = _this.props).onInteractionStart) === null || _c === void 0 ? void 0 : _c.call(_b);\n    };\n\n    _this.onDrag = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      if (_this.rafDragTimeout) window.cancelAnimationFrame(_this.rafDragTimeout);\n      _this.rafDragTimeout = window.requestAnimationFrame(function () {\n        if (!_this.state.cropSize) return;\n        if (x === undefined || y === undefined) return;\n        var offsetX = x - _this.dragStartPosition.x;\n        var offsetY = y - _this.dragStartPosition.y;\n        var requestedPosition = {\n          x: _this.dragStartCrop.x + offsetX,\n          y: _this.dragStartCrop.y + offsetY\n        };\n        var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : requestedPosition;\n\n        _this.props.onCropChange(newPosition);\n      });\n    };\n\n    _this.onDragStopped = function () {\n      var _a, _b;\n\n      _this.cleanEvents();\n\n      _this.emitCropData();\n\n      (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n\n    _this.onWheel = function (e) {\n      e.preventDefault();\n      var point = Cropper.getMousePoint(e);\n      var newZoom = _this.props.zoom - e.deltaY * _this.props.zoomSpeed / 200;\n\n      _this.setNewZoom(newZoom, point);\n\n      if (!_this.state.hasWheelJustStarted) {\n        _this.setState({\n          hasWheelJustStarted: true\n        }, function () {\n          var _a, _b;\n\n          return (_b = (_a = _this.props).onInteractionStart) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }\n\n      if (_this.wheelTimer) {\n        clearTimeout(_this.wheelTimer);\n      }\n\n      _this.wheelTimer = window.setTimeout(function () {\n        return _this.setState({\n          hasWheelJustStarted: false\n        }, function () {\n          var _a, _b;\n\n          return (_b = (_a = _this.props).onInteractionEnd) === null || _b === void 0 ? void 0 : _b.call(_a);\n        });\n      }, 250);\n    };\n\n    _this.getPointOnContainer = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n\n      if (!_this.containerRect) {\n        throw new Error('The Cropper is not mounted');\n      }\n\n      return {\n        x: _this.containerRect.width / 2 - (x - _this.containerRect.left),\n        y: _this.containerRect.height / 2 - (y - _this.containerRect.top)\n      };\n    };\n\n    _this.getPointOnMedia = function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var _b = _this.props,\n          crop = _b.crop,\n          zoom = _b.zoom;\n      return {\n        x: (x + crop.x) / zoom,\n        y: (y + crop.y) / zoom\n      };\n    };\n\n    _this.setNewZoom = function (zoom, point) {\n      if (!_this.state.cropSize || !_this.props.onZoomChange) return;\n\n      var zoomPoint = _this.getPointOnContainer(point);\n\n      var zoomTarget = _this.getPointOnMedia(zoomPoint);\n\n      var newZoom = Math.min(_this.props.maxZoom, Math.max(zoom, _this.props.minZoom));\n      var requestedPosition = {\n        x: zoomTarget.x * newZoom - zoomPoint.x,\n        y: zoomTarget.y * newZoom - zoomPoint.y\n      };\n      var newPosition = _this.props.restrictPosition ? restrictPosition(requestedPosition, _this.mediaSize, _this.state.cropSize, newZoom, _this.props.rotation) : requestedPosition;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.props.onZoomChange(newZoom);\n    };\n\n    _this.emitCropData = function () {\n      if (!_this.state.cropSize) return; // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n\n      var restrictedPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n\n      var _a = computeCroppedArea(restrictedPosition, _this.mediaSize, _this.state.cropSize, _this.getAspect(), _this.props.zoom, _this.props.rotation, _this.props.restrictPosition),\n          croppedAreaPercentages = _a.croppedAreaPercentages,\n          croppedAreaPixels = _a.croppedAreaPixels;\n\n      _this.props.onCropComplete && _this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels);\n    };\n\n    _this.recomputeCropPosition = function () {\n      if (!_this.state.cropSize) return;\n      var newPosition = _this.props.restrictPosition ? restrictPosition(_this.props.crop, _this.mediaSize, _this.state.cropSize, _this.props.zoom, _this.props.rotation) : _this.props.crop;\n\n      _this.props.onCropChange(newPosition);\n\n      _this.emitCropData();\n    };\n\n    return _this;\n  }\n\n  Cropper.prototype.componentDidMount = function () {\n    window.addEventListener('resize', this.computeSizes);\n\n    if (this.containerRef) {\n      this.containerRef.addEventListener('wheel', this.onWheel, {\n        passive: false\n      });\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari);\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari);\n    } // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n\n\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad();\n    }\n  };\n\n  Cropper.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.computeSizes);\n\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('wheel', this.onWheel);\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari);\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari);\n    }\n\n    this.cleanEvents();\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer);\n    }\n  };\n\n  Cropper.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes();\n      this.recomputeCropPosition();\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes();\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition();\n    }\n  };\n\n  Cropper.prototype.getAspect = function () {\n    var _a = this.props,\n        cropSize = _a.cropSize,\n        aspect = _a.aspect;\n\n    if (cropSize) {\n      return cropSize.width / cropSize.height;\n    }\n\n    return aspect;\n  };\n\n  Cropper.prototype.onPinchStart = function (e) {\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB);\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB);\n    this.onDragStart(getCenter(pointA, pointB));\n  };\n\n  Cropper.prototype.onPinchMove = function (e) {\n    var _this = this;\n\n    var pointA = Cropper.getTouchPoint(e.touches[0]);\n    var pointB = Cropper.getTouchPoint(e.touches[1]);\n    var center = getCenter(pointA, pointB);\n    this.onDrag(center);\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout);\n    this.rafPinchTimeout = window.requestAnimationFrame(function () {\n      var distance = getDistanceBetweenPoints(pointA, pointB);\n      var newZoom = _this.props.zoom * (distance / _this.lastPinchDistance);\n\n      _this.setNewZoom(newZoom, center);\n\n      _this.lastPinchDistance = distance;\n      var rotation = getRotationBetweenPoints(pointA, pointB);\n      var newRotation = _this.props.rotation + (rotation - _this.lastPinchRotation);\n      _this.props.onRotationChange && _this.props.onRotationChange(newRotation);\n      _this.lastPinchRotation = rotation;\n    });\n  };\n\n  Cropper.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        image = _a.image,\n        video = _a.video,\n        mediaProps = _a.mediaProps,\n        _b = _a.crop,\n        x = _b.x,\n        y = _b.y,\n        rotation = _a.rotation,\n        zoom = _a.zoom,\n        cropShape = _a.cropShape,\n        showGrid = _a.showGrid,\n        _c = _a.style,\n        containerStyle = _c.containerStyle,\n        cropAreaStyle = _c.cropAreaStyle,\n        mediaStyle = _c.mediaStyle,\n        _d = _a.classes,\n        containerClassName = _d.containerClassName,\n        cropAreaClassName = _d.cropAreaClassName,\n        mediaClassName = _d.mediaClassName;\n    return React.createElement(Container, {\n      onMouseDown: this.onMouseDown,\n      onTouchStart: this.onTouchStart,\n      ref: function ref(el) {\n        return _this.containerRef = el;\n      },\n      \"data-testid\": \"container\",\n      style: containerStyle,\n      className: containerClassName\n    }, image ? React.createElement(Img, __assign({\n      alt: \"\",\n      className: mediaClassName\n    }, mediaProps, {\n      src: image,\n      ref: function ref(el) {\n        return _this.imageRef = el;\n      },\n      style: __assign(__assign({}, mediaStyle), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      onLoad: this.onMediaLoad\n    })) : video && React.createElement(Video, __assign({\n      autoPlay: true,\n      loop: true,\n      muted: true,\n      alt: \"\",\n      className: mediaClassName\n    }, mediaProps, {\n      src: video,\n      ref: function ref(el) {\n        return _this.videoRef = el;\n      },\n      onLoadedMetadata: this.onMediaLoad,\n      style: __assign(__assign({}, mediaStyle), {\n        transform: \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"deg) scale(\" + zoom + \")\"\n      }),\n      controls: false\n    })), this.state.cropSize && React.createElement(CropArea, {\n      cropShape: cropShape,\n      showGrid: showGrid,\n      style: __assign(__assign({}, cropAreaStyle), {\n        width: this.state.cropSize.width,\n        height: this.state.cropSize.height\n      }),\n      \"data-testid\": \"cropper\",\n      className: cropAreaClassName\n    }));\n  };\n\n  Cropper.defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true\n  };\n\n  Cropper.getMousePoint = function (e) {\n    return {\n      x: Number(e.clientX),\n      y: Number(e.clientY)\n    };\n  };\n\n  Cropper.getTouchPoint = function (touch) {\n    return {\n      x: Number(touch.clientX),\n      y: Number(touch.clientY)\n    };\n  };\n\n  return Cropper;\n}(React.Component);\n\nexport default Cropper;","map":{"version":3,"sources":["../src/styles.ts","../src/helpers.ts","../src/index.tsx"],"names":["Container","position","top","left","right","bottom","overflow","userSelect","touchAction","cursor","mediaStyles","maxWidth","maxHeight","margin","willChange","Img","styled","Video","lineBorder","cropperLines","content","boxSizing","border","cropperArea","transform","boxShadow","color","gridLines","borderTop","borderBottom","borderLeft","borderRight","roundShape","borderRadius","CropArea","cropShape","showGrid","getCropSize","mediaWidth","mediaHeight","aspect","rotation","_a","width","height","restrictPosition","mediaSize","cropSize","zoom","x","restrictPositionCoord","y","maxPosition","Math","getDistanceBetweenPoints","pointA","pointB","getRotationBetweenPoints","computeCroppedArea","crop","limitAreaFn","croppedAreaPercentages","widthInPixels","heightInPixels","isImgWiderThanHigh","sizePixels","croppedAreaPixels","mediaZoom","isHeightMaxSize_1","isHeightMaxSize","getInitialCropFromCroppedAreaPixels","getZoomFromCroppedAreaPixels","cropZoom","getCenter","a","b","rotateAroundMidPoint","xMid","yMid","degrees","cos","sin","radian","xr","yr","translateSize","centerX","centerY","outerBounds","minX","p","maxX","minY","maxY","MIN_ZOOM","MAX_ZOOM","__extends","Cropper","maxZoom","minZoom","style","classes","mediaProps","zoomSpeed","_this","naturalWidth","naturalHeight","hasWheelJustStarted","window","passive","clearTimeout","prevProps","e","document","initialCroppedAreaPixels","_b","mediaRef","imageRef","videoRef","Number","touch","offsetX","offsetY","requestedPosition","newPosition","center","distance","newZoom","newRotation","point","onInteractionStart","onInteractionEnd","zoomPoint","zoomTarget","restrictedPosition","image","video","_c","containerStyle","cropAreaStyle","mediaStyle","_d","containerClassName","cropAreaClassName","mediaClassName","onMouseDown","onTouchStart","ref","className","alt","src","onLoad","onMediaLoad","autoPlay","loop","muted","onLoadedMetadata","controls"],"mappings":";;;AAEO,IAAMA,SAAS,GAAG,MAAM,CAAN,KAAM,CAAN,CAAc;AACrCC,EAAAA,QAAQ,EAD6B,UAAA;AAErCC,EAAAA,GAAG,EAFkC,CAAA;AAGrCC,EAAAA,IAAI,EAHiC,CAAA;AAIrCC,EAAAA,KAAK,EAJgC,CAAA;AAKrCC,EAAAA,MAAM,EAL+B,CAAA;AAMrCC,EAAAA,QAAQ,EAN6B,QAAA;AAOrCC,EAAAA,UAAU,EAP2B,MAAA;AAQrCC,EAAAA,WAAW,EAR0B,MAAA;AASrCC,EAAAA,MAAM,EAAE;AAT6B,CAAd,CAAlB;AAYP,IAAMC,WAAW,GAAG;AAClBC,EAAAA,QAAQ,EADU,MAAA;AAElBC,EAAAA,SAAS,EAFS,MAAA;AAGlBC,EAAAA,MAAM,EAHY,MAAA;AAIlBZ,EAAAA,QAAQ,EAJU,UAAA;AAKlBC,EAAAA,GAAG,EALe,CAAA;AAMlBG,EAAAA,MAAM,EANY,CAAA;AAOlBF,EAAAA,IAAI,EAPc,CAAA;AAQlBC,EAAAA,KAAK,EARa,CAAA;AASlBU,EAAAA,UAAU,EAAE;AATM,CAApB,C,CAAA;;AAaO,IAAMC,GAAG,GAAGC,MAAM,CAANA,KAAM,CAANA,CAAZ,WAAYA,CAAZ,C,CAAA;;AAEA,IAAMC,KAAK,GAAGD,MAAM,CAANA,OAAM,CAANA,CAAd,WAAcA,CAAd;AAEP,IAAME,UAAU,GAAhB,oCAAA;AACA,IAAMC,YAAY,GAAG;AACnBC,EAAAA,OAAO,EADY,KAAA;AAEnBC,EAAAA,SAAS,EAFU,YAAA;AAGnBpB,EAAAA,QAAQ,EAHW,UAAA;AAInBqB,EAAAA,MAAM,EAAEJ;AAJW,CAArB;AAMA,IAAMK,WAAW,GAAG;AAClBtB,EAAAA,QAAQ,EADU,UAAA;AAElBE,EAAAA,IAAI,EAFc,KAAA;AAGlBD,EAAAA,GAAG,EAHe,KAAA;AAIlBsB,EAAAA,SAAS,EAJS,uBAAA;AAKlBF,EAAAA,MAAM,EALY,UAAA;AAMlBD,EAAAA,SAAS,EANS,YAAA;AAOlBI,EAAAA,SAAS,EAPS,cAAA;AAQlBC,EAAAA,KAAK,EARa,iBAAA;AASlBpB,EAAAA,QAAQ,EAAE;AATQ,CAApB;AAWA,IAAMqB,SAAS,GAAG;qCAEXR,Y,GAAAA;AACHjB,IAAAA,GAAG,EAAE,CADFiB;AAEHd,IAAAA,MAAM,EAAE,CAFLc;AAGHhB,IAAAA,IAAI,EAAE,QAHHgB;AAIHf,IAAAA,KAAK,EAAE,QAJJe;AAKHS,IAAAA,SAAS,EAAE,CALRT;AAMHU,IAAAA,YAAY,EAAE;AANXV,G,CAFW;oCAWXA,Y,GAAAA;AACHjB,IAAAA,GAAG,EAAE,QADFiB;AAEHd,IAAAA,MAAM,EAAE,QAFLc;AAGHhB,IAAAA,IAAI,EAAE,CAHHgB;AAIHf,IAAAA,KAAK,EAAE,CAJJe;AAKHW,IAAAA,UAAU,EAAE,CALTX;AAMHY,IAAAA,WAAW,EAAE;AANVZ,G;AAXW,CAAlB;AAoBA,IAAMa,UAAU,GAAG;AACjBC,EAAAA,YAAY,EAAE;AADG,CAAnB,C,CAAA;;AAUO,IAAMC,QAAQ,GAAG,MAAM,CAAN,KAAM,CAAN,CAAA,EAAA,EAAkB,UAAA,EAAA,EAAA;MAAGC,SAAAA,GAAAA,EAAAA,CAAAA,S;MAAWC,QAAAA,GAAAA,EAAAA,CAAAA,Q;+BAClD,YAAA;YACF,S;WACE,O;qCACcb,W,GAAZ,U;;WACF,M;;eAEE,W;;AANH,GAAC,E,GASAa,QAAQ,GAAA,SAAA,GAVwE,E;AAA/E,CAAiB,CAAjB;AC7EP;;;;;AAIA,SAAgBC,WAAhB,CACEC,UADF,EAEEC,WAFF,EAGEC,MAHF,EAIEC,QAJF,EAIEA;wBAAAA,C,EAAAA;AAAAA,IAAAA,QAAAA,GAAAA,CAAAA;;;MAEMC,EAAAA,GAAAA,aAAAA,CAAAA,UAAAA,EAAAA,WAAAA,EAAAA,QAAAA,C;MAAEC,KAAAA,GAAAA,EAAAA,CAAFD,K;MAASE,MAAAA,GAAAA,EAAAA,CAATF,M;;MAEFJ,UAAU,IAAIC,WAAW,GAAzBD,MAAAA,IAAsCK,KAAK,GAAGJ,WAAW,GAA7D,M,EAAwE;WAC/D;AACLI,MAAAA,KAAK,EAAEJ,WAAW,GADb,MAAA;AAELK,MAAAA,MAAM,EAAEL;AAFH,K;;;MAMLI,KAAK,GAAGJ,WAAW,GAAvB,M,EAAkC;WACzB;AACLI,MAAAA,KAAK,EADA,UAAA;AAELC,MAAAA,MAAM,EAAEN,UAAU,GAAGE;AAFhB,K;;;MAMLG,KAAK,GAAGC,MAAM,GAAlB,M,EAA6B;WACpB;AACLD,MAAAA,KAAK,EAAEC,MAAM,GADR,MAAA;AAELA,MAAAA,MAAM,EAAEA;AAFH,K;;;SAMF;AACLD,IAAAA,KAAK,EADA,KAAA;AAELC,IAAAA,MAAM,EAAED,KAAK,GAAGH;AAFX,G;;;;;;;AAST,SAAgBK,gBAAhB,CACE5C,QADF,EAEE6C,SAFF,EAGEC,QAHF,EAIEC,IAJF,EAKEP,QALF,EAKEA;wBAAAA,C,EAAAA;AAAAA,IAAAA,QAAAA,GAAAA,CAAAA;;;MAEMC,EAAAA,GAAAA,aAAAA,CAAAA,SAAAA,CAAAA,KAAAA,EAAAA,SAAAA,CAAAA,MAAAA,EAAAA,QAAAA,C;MAAEC,KAAAA,GAAAA,EAAAA,CAAFD,K;MAASE,MAAAA,GAAAA,EAAAA,CAATF,M;;SAEC;AACLO,IAAAA,CAAC,EAAEC,qBAAqB,CAACjD,QAAQ,CAAT,CAAA,EAAA,KAAA,EAAoB8C,QAAQ,CAA5B,KAAA,EADnB,IACmB,CADnB;AAELI,IAAAA,CAAC,EAAED,qBAAqB,CAACjD,QAAQ,CAAT,CAAA,EAAA,MAAA,EAAqB8C,QAAQ,CAA7B,MAAA,EAAA,IAAA;AAFnB,G;;;AAMT,SAAA,qBAAA,CAAA,QAAA,EAAA,SAAA,EAAA,QAAA,EAAA,IAAA,EAAA;MAMQK,WAAW,GAAIN,SAAS,GAAV,IAACA,GAAD,CAACA,GAAwBC,QAAQ,GAArD,C;SACOM,IAAI,CAAJA,GAAAA,CAAAA,WAAAA,EAAsBA,IAAI,CAAJA,GAAAA,CAAAA,QAAAA,EAAmB,CAAhD,WAA6BA,CAAtBA,C;;;AAGT,SAAgBC,wBAAhB,CAAyCC,MAAzC,EAAwDC,MAAxD,EAAwDA;SAC/CH,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAASE,MAAM,CAANA,CAAAA,GAAWC,MAAM,CAA1BH,CAAAA,EAAAA,CAAAA,IAAmCA,IAAI,CAAJA,GAAAA,CAASE,MAAM,CAANA,CAAAA,GAAWC,MAAM,CAA1BH,CAAAA,EAApD,CAAoDA,CAA7CA,C;;;AAGT,SAAgBI,wBAAhB,CAAyCF,MAAzC,EAAwDC,MAAxD,EAAwDA;SAC9CH,IAAI,CAAJA,KAAAA,CAAWG,MAAM,CAANA,CAAAA,GAAWD,MAAM,CAA5BF,CAAAA,EAAgCG,MAAM,CAANA,CAAAA,GAAWD,MAAM,CAAjDF,CAAAA,IAAD,GAACA,GAA8DA,IAAI,CAA1E,E;;;;;;;;AAOF,SAAgBK,kBAAhB,CACEC,IADF,EAEEb,SAFF,EAGEC,QAHF,EAIEP,MAJF,EAKEQ,IALF,EAMEP,QANF,EAOEI,gBAPF,EAOEA;wBADAJ,C,EAAAA;AAAAA,IAAAA,QAAAA,GAAAA,CAAAA;;;gCACAI,C,EAAAA;AAAAA,IAAAA,gBAAAA,GAAAA,IAAAA;GAAAA,C;;;;MAIMe,WAAW,GAAGf,gBAAgB,IAAIJ,QAAQ,KAA5BI,CAAAA,GAAAA,SAAAA,GAApB,I;MACMgB,sBAAsB,GAAG;AAC7BZ,IAAAA,CAAC,EAAEW,WAAW,CAAA,GAAA,EAEX,CAAC,CAACd,SAAS,CAATA,KAAAA,GAAkBC,QAAQ,CAARA,KAAAA,GAAnB,IAAA,IAAA,CAAA,GAAgDY,IAAI,CAAJA,CAAAA,GAAjD,IAAA,IAAkEb,SAAS,CAA5E,KAAC,GAH0B,GACf,CADe;AAK7BK,IAAAA,CAAC,EAAES,WAAW,CAAA,GAAA,EAEX,CAAC,CAACd,SAAS,CAATA,MAAAA,GAAmBC,QAAQ,CAARA,MAAAA,GAApB,IAAA,IAAA,CAAA,GAAkDY,IAAI,CAAJA,CAAAA,GAAnD,IAAA,IAAoEb,SAAS,CAA9E,MAAC,GAP0B,GAKf,CALe;AAS7BH,IAAAA,KAAK,EAAEiB,WAAW,CAAA,GAAA,EAAQb,QAAQ,CAARA,KAAAA,GAAiBD,SAAS,CAA3B,KAACC,GAAF,GAAEA,GATG,IASX,CATW;AAU7BH,IAAAA,MAAM,EAAEgB,WAAW,CAAA,GAAA,EAAQb,QAAQ,CAARA,MAAAA,GAAkBD,SAAS,CAA5B,MAACC,GAAF,GAAEA,GAAR,IAAA;AAVU,G,CAL/BF,CAKA;;MAcMiB,aAAa,GAAGT,IAAI,CAAJA,KAAAA,CACpBO,WAAW,CACTd,SAAS,CADA,YAAA,EAERe,sBAAsB,CAAtBA,KAAAA,GAA+Bf,SAAS,CAAzC,YAACe,GAHL,GACa,CADSR,C;MAMhBU,cAAc,GAAGV,IAAI,CAAJA,KAAAA,CACrBO,WAAW,CACTd,SAAS,CADA,aAAA,EAERe,sBAAsB,CAAtBA,MAAAA,GAAgCf,SAAS,CAA1C,aAACe,GAHL,GACa,CADUR,C;MAMjBW,kBAAkB,GAAGlB,SAAS,CAATA,YAAAA,IAA0BA,SAAS,CAATA,aAAAA,GAArD,M,CA/BAD,CA+BA;;;;;MAMMoB,UAAU,GAAGD,kBAAkB,GACjC;AACErB,IAAAA,KAAK,EAAEU,IAAI,CAAJA,KAAAA,CAAWU,cAAc,GADlC,MACSV,CADT;AAEET,IAAAA,MAAM,EAAEmB;AAFV,GADiC,GAKjC;AACEpB,IAAAA,KAAK,EADP,aAAA;AAEEC,IAAAA,MAAM,EAAES,IAAI,CAAJA,KAAAA,CAAWS,aAAa,GAAxBT,MAAAA;AAFV,G;;MAIEa,iBAAiB,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAClBD,UADkB,CAAA,EAClBA;AACHhB,IAAAA,CAAC,EAAEI,IAAI,CAAJA,KAAAA,CACDO,WAAW,CACTd,SAAS,CAATA,YAAAA,GAAyBmB,UAAU,CAD1B,KAAA,EAERJ,sBAAsB,CAAtBA,CAAAA,GAA2Bf,SAAS,CAArC,YAACe,GAHFR,GACU,CADVA,CADAY;AAOHd,IAAAA,CAAC,EAAEE,IAAI,CAAJA,KAAAA,CACDO,WAAW,CACTd,SAAS,CAATA,aAAAA,GAA0BmB,UAAU,CAD3B,MAAA,EAERJ,sBAAsB,CAAtBA,CAAAA,GAA2Bf,SAAS,CAArC,aAACe,GAHFR,GACU,CADVA;AAPAY,GADkB,C;;SAehB;AAAEJ,IAAAA,sBAAsB,EAAxB,sBAAA;AAA0BK,IAAAA,iBAAiB,EAAA;AAA3C,G;;;;;;;AAMT,SAAA,SAAA,CAAA,GAAA,EAAA,KAAA,EAAA;SACSb,IAAI,CAAJA,GAAAA,CAAAA,GAAAA,EAAcA,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAArB,KAAqBA,CAAdA,C;;;AAGT,SAAA,IAAA,CAAA,IAAA,EAAA,KAAA,EAAA;SACE,K;;;;;;;AAMF,SAAA,4BAAA,CAAA,iBAAA,EAAA,SAAA,EAAA,QAAA,EAAA;MAKQc,SAAS,GAAGrB,SAAS,CAATA,KAAAA,GAAkBA,SAAS,CAA7C,Y;;MAEA,Q,EAAc;QACNsB,iBAAe,GAAGrB,QAAQ,CAARA,MAAAA,GAAkBA,QAAQ,CAAlD,K;WACOqB,iBAAe,GAClBrB,QAAQ,CAARA,MAAAA,GAAAA,SAAAA,GAA8BmB,iBAAiB,CAD7B,MAAA,GAElBnB,QAAQ,CAARA,KAAAA,GAAAA,SAAAA,GAA6BmB,iBAAiB,CAFlD,K;;;MAKI1B,MAAM,GAAG0B,iBAAiB,CAAjBA,KAAAA,GAA0BA,iBAAiB,CAA1D,M;MACMG,eAAe,GAAGvB,SAAS,CAATA,YAAAA,IAA0BA,SAAS,CAATA,aAAAA,GAAlD,M;SACOuB,eAAe,GAClBvB,SAAS,CAATA,aAAAA,GAA0BoB,iBAAiB,CADzB,MAAA,GAElBpB,SAAS,CAATA,YAAAA,GAAyBoB,iBAAiB,CAF9C,K;;;;;;;AAQF,SAAgBI,mCAAhB,CACEJ,iBADF,EAEEpB,SAFF,EAGEC,QAHF,EAGEA;MAEMoB,SAAS,GAAGrB,SAAS,CAATA,KAAAA,GAAkBA,SAAS,CAA7C,Y;MAEME,IAAI,GAAGuB,4BAA4B,CAAA,iBAAA,EAAA,SAAA,EAAzC,QAAyC,C;MAEnCC,QAAQ,GAAGL,SAAS,GAA1B,I;MAEMR,IAAI,GAAG;AACXV,IAAAA,CAAC,EAAE,CAAC,CAACH,SAAS,CAATA,YAAAA,GAAyBoB,iBAAiB,CAA3C,KAAA,IAAA,CAAA,GAAyDA,iBAAiB,CAA3E,CAAA,IADQ,QAAA;AAEXf,IAAAA,CAAC,EAAE,CAAC,CAACL,SAAS,CAATA,aAAAA,GAA0BoB,iBAAiB,CAA5C,MAAA,IAAA,CAAA,GAA2DA,iBAAiB,CAA7E,CAAA,IAAmFM;AAF3E,G;SAIN;AAAEb,IAAAA,IAAI,EAAN,IAAA;AAAQX,IAAAA,IAAI,EAAA;AAAZ,G;;;;;;;AAMT,SAAgByB,SAAhB,CAA0BC,CAA1B,EAAoCC,CAApC,EAAoCA;SAC3B;AACL1B,IAAAA,CAAC,EAAE,CAAC0B,CAAC,CAADA,CAAAA,GAAMD,CAAC,CAAR,CAAA,IADE,CAAA;AAELvB,IAAAA,CAAC,EAAE,CAACwB,CAAC,CAADA,CAAAA,GAAMD,CAAC,CAAR,CAAA,IAAc;AAFZ,G;;;;;;;;AAUT,SAAgBE,oBAAhB,CACE3B,CADF,EAEEE,CAFF,EAGE0B,IAHF,EAIEC,IAJF,EAKEC,OALF,EAKEA;MAEMC,GAAG,GAAG3B,IAAI,CAAhB,G;MACM4B,GAAG,GAAG5B,IAAI,CAAhB,G;MACM6B,MAAM,GAAIH,OAAO,GAAG1B,IAAI,CAAf,EAAC0B,GAAhB,G,CAJAA,CAIA;;;;MAGMI,EAAE,GAAG,CAAClC,CAAC,GAAF,IAAA,IAAa+B,GAAG,CAAhB,MAAgB,CAAhB,GAA2B,CAAC7B,CAAC,GAAF,IAAA,IAAa8B,GAAG,CAA3C,MAA2C,CAA3C,GAAX,I;MACMG,EAAE,GAAG,CAACnC,CAAC,GAAF,IAAA,IAAagC,GAAG,CAAhB,MAAgB,CAAhB,GAA2B,CAAC9B,CAAC,GAAF,IAAA,IAAa6B,GAAG,CAA3C,MAA2C,CAA3C,GAAX,I;SAEO,CAAA,EAAA,EAAP,EAAO,C;;;;;;;AAMT,SAAgBK,aAAhB,CAA8B1C,KAA9B,EAA6CC,MAA7C,EAA6DH,QAA7D,EAA6DA;MACrD6C,OAAO,GAAG3C,KAAK,GAArB,C;MACM4C,OAAO,GAAG3C,MAAM,GAAtB,C;MAEM4C,WAAW,GAAG,CAClBZ,oBAAoB,CAAA,CAAA,EAAA,CAAA,EAAA,OAAA,EAAA,OAAA,EADF,QACE,CADF,EAElBA,oBAAoB,CAAA,KAAA,EAAA,CAAA,EAAA,OAAA,EAAA,OAAA,EAFF,QAEE,CAFF,EAGlBA,oBAAoB,CAAA,KAAA,EAAA,MAAA,EAAA,OAAA,EAAA,OAAA,EAHF,QAGE,CAHF,EAIlBA,oBAAoB,CAAA,CAAA,EAAA,MAAA,EAAA,OAAA,EAAA,OAAA,EAJtB,QAIsB,CAJF,C;MAOda,IAAI,GAAG,IAAI,CAAJ,GAAA,CAAA,KAAA,CAAA,IAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,CAAA,EAAA;WAAKC,CAAC,CAADA,CAAC,C;AAA/C,GAAyB,CAAZ,C;MACPC,IAAI,GAAG,IAAI,CAAJ,GAAA,CAAA,KAAA,CAAA,IAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,CAAA,EAAA;WAAKD,CAAC,CAADA,CAAC,C;AAA/C,GAAyB,CAAZ,C;MACPE,IAAI,GAAG,IAAI,CAAJ,GAAA,CAAA,KAAA,CAAA,IAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,CAAA,EAAA;WAAKF,CAAC,CAADA,CAAC,C;AAA/C,GAAyB,CAAZ,C;MACPG,IAAI,GAAG,IAAI,CAAJ,GAAA,CAAA,KAAA,CAAA,IAAA,EAAY,WAAW,CAAX,GAAA,CAAgB,UAAA,CAAA,EAAA;WAAKH,CAAC,CAADA,CAAC,C;AAA/C,GAAyB,CAAZ,C;SAEN;AAAE/C,IAAAA,KAAK,EAAEgD,IAAI,GAAb,IAAA;AAAsB/C,IAAAA,MAAM,EAAEiD,IAAI,GAAGD;AAArC,G;;;AC9MT,IAAME,QAAQ,GAAd,CAAA;AACA,IAAMC,QAAQ,GAAd,CAAA;;AAEA,IAAA,OAAA;;;AAAsBC,EAAAA,SAAAA,CAAAA,OAAAA,EAAAA,MAAAA,CAAAA;;WAAtB,O,GAAA;oEAAA,I;;AAgBEQ,IAAAA,KAAAA,CAAAA,QAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,QAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,YAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,aAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,SAAAA,GAAuB;AAAE7D,MAAAA,KAAK,EAAP,CAAA;AAAYC,MAAAA,MAAM,EAAlB,CAAA;AAAuB6D,MAAAA,YAAY,EAAnC,CAAA;AAAwCC,MAAAA,aAAa,EAAE;AAAvD,KAAvBF;AACAA,IAAAA,KAAAA,CAAAA,iBAAAA,GAA2B;AAAEvD,MAAAA,CAAC,EAAH,CAAA;AAAQE,MAAAA,CAAC,EAAE;AAAX,KAA3BqD;AACAA,IAAAA,KAAAA,CAAAA,aAAAA,GAAuB;AAAEvD,MAAAA,CAAC,EAAH,CAAA;AAAQE,MAAAA,CAAC,EAAE;AAAX,KAAvBqD;AACAA,IAAAA,KAAAA,CAAAA,iBAAAA,GAAAA,CAAAA;AACAA,IAAAA,KAAAA,CAAAA,iBAAAA,GAAAA,CAAAA;AACAA,IAAAA,KAAAA,CAAAA,cAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,eAAAA,GAAAA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,UAAAA,GAAAA,IAAAA;AAEAA,IAAAA,KAAAA,CAAAA,KAAAA,GAAe;AACbzD,MAAAA,QAAQ,EADK,IAAA;AAEb4D,MAAAA,mBAAmB,EAAE;AAFR,KAAfH,CA7BF,CA6BEA;;AA4CAA,IAAAA,KAAAA,CAAAA,iBAAAA,GAAoB,UAAA,CAAA,EAAA;aAAcQ,CAAC,CAADA,cAAAA,E;AAAlCR,KAAAA;;AAEAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,YAAA;AACZS,MAAAA,QAAQ,CAARA,mBAAAA,CAAAA,WAAAA,EAA0CT,KAAI,CAA9CS,WAAAA;AACAA,MAAAA,QAAQ,CAARA,mBAAAA,CAAAA,SAAAA,EAAwCT,KAAI,CAA5CS,aAAAA;AACAA,MAAAA,QAAQ,CAARA,mBAAAA,CAAAA,WAAAA,EAA0CT,KAAI,CAA9CS,WAAAA;AACAA,MAAAA,QAAQ,CAARA,mBAAAA,CAAAA,UAAAA,EAAyCT,KAAI,CAA7CS,aAAAA;AAJFT,KAAAA;;AAOAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,YAAA;AACZA,MAAAA,KAAI,CAAJA,YAAAA;;AACAA,MAAAA,KAAI,CAAJA,YAAAA;;AACAA,MAAAA,KAAI,CAAJA,cAAAA;;UAEIA,KAAI,CAAJA,KAAAA,CAAJ,a,EAA8B;AAC5BA,QAAAA,KAAI,CAAJA,KAAAA,CAAAA,aAAAA,CAAyBA,KAAI,CAA7BA,SAAAA;;AANJA,KAAAA;;AAUAA,IAAAA,KAAAA,CAAAA,cAAAA,GAAiB,YAAA;UACT9D,EAAAA,GAAAA,KAAAA,CAAAA,K;UAAEwE,wBAAAA,GAAAA,EAAAA,CAAFxE,wB;UAA4BK,QAAAA,GAAAA,EAAAA,CAA5BL,Q;;UAEF,CAAJ,wB,EAA+B;;;;UAIzByE,EAAAA,GAAAA,mCAAAA,CAAAA,wBAAAA,EAAAA,KAAAA,CAAAA,SAAAA,EAAAA,QAAAA,C;UAAExD,IAAAA,GAAAA,EAAAA,CAAFwD,I;UAAQnE,IAAAA,GAAAA,EAAAA,CAARmE,I;;AAKNX,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAAAA,IAAAA;;AACAA,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,IAA2BA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAA3BA,IAA2BA,CAA3BA;AAbFA,KAAAA;;AAwBAA,IAAAA,KAAAA,CAAAA,YAAAA,GAAe,YAAA;;;UACPY,QAAQ,GAAGZ,KAAI,CAAJA,QAAAA,IAAiBA,KAAI,CAAtC,Q;;UACA,Q,EAAc;AACZA,QAAAA,KAAI,CAAJA,SAAAA,GAAiB;AACf7D,UAAAA,KAAK,EAAEyE,QAAQ,CADA,WAAA;AAEfxE,UAAAA,MAAM,EAAEwE,QAAQ,CAFD,YAAA;AAGfX,UAAAA,YAAY,EAAE,CAAA,CAAA,EAAA,GAAA,KAAI,CAACY,QAAL,MAAKA,IAAL,IAAKA,EAAAA,KAAAA,KAAAA,CAAL,GAAKA,KAAAA,CAAL,GAAKA,EAAAA,CAAL,YAAA,MAAA,CAAA,EAAA,GAA+Bb,KAAI,CAACc,QAApC,MAAoCA,IAApC,IAAoCA,EAAAA,KAAAA,KAAAA,CAApC,GAAoCA,KAAAA,CAApC,GAAoCA,EAAAA,CAApC,UAAA,KAHC,CAAA;AAIfZ,UAAAA,aAAa,EAAE,CAAA,CAAA,EAAA,GAAA,KAAI,CAACW,QAAL,MAAKA,IAAL,IAAKA,EAAAA,KAAAA,KAAAA,CAAL,GAAKA,KAAAA,CAAL,GAAKA,EAAAA,CAAL,aAAA,MAAA,CAAA,EAAA,GAAgCb,KAAI,CAACc,QAArC,MAAqCA,IAArC,IAAqCA,EAAAA,KAAAA,KAAAA,CAArC,GAAqCA,KAAAA,CAArC,GAAqCA,EAAAA,CAArC,WAAA,KAA8D;AAJ9D,SAAjBd;YAMMzD,QAAQ,GAAGyD,KAAI,CAAJA,KAAAA,CAAAA,QAAAA,GACbA,KAAI,CAAJA,KAAAA,CADaA,QAAAA,GAEbnE,WAAW,CACT+E,QAAQ,CADC,WAAA,EAETA,QAAQ,CAFC,YAAA,EAGTZ,KAAI,CAAJA,KAAAA,CAHS,MAAA,EAITA,KAAI,CAAJA,KAAAA,CANN,QAEe,C;;AAMfA,QAAAA,KAAI,CAAJA,QAAAA,CAAc;AAAEzD,UAAAA,QAAQ,EAAA;AAAV,SAAdyD,EAA4BA,KAAI,CAAhCA,qBAAAA;;;UAEEA,KAAI,CAAR,Y,EAAuB;AACrBA,QAAAA,KAAI,CAAJA,aAAAA,GAAqBA,KAAI,CAAJA,YAAAA,CAArBA,qBAAqBA,EAArBA;;AApBJA,KAAAA;;AAkCAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,UAAA,CAAA,EAAA;AACZQ,MAAAA,CAAC,CAADA,cAAAA;AACAC,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,WAAAA,EAAuCT,KAAI,CAA3CS,WAAAA;AACAA,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,SAAAA,EAAqCT,KAAI,CAAzCS,aAAAA;;AACAT,MAAAA,KAAI,CAAJA,WAAAA,CAAiBP,OAAO,CAAPA,aAAAA,CAAjBO,CAAiBP,CAAjBO;AAJFA,KAAAA;;AAOAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,UAAA,CAAA,EAAA;aAAmBA,KAAI,CAAJA,MAAAA,CAAYP,OAAO,CAAPA,aAAAA,CAAZO,CAAYP,CAAZO,C;AAAjCA,KAAAA;;AAEAA,IAAAA,KAAAA,CAAAA,YAAAA,GAAe,UAAA,CAAA,EAAA;AACbQ,MAAAA,CAAC,CAADA,cAAAA;AACAC,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,WAAAA,EAAuCT,KAAI,CAA3CS,WAAAA,EAAyD;AAAEJ,QAAAA,OAAO,EAAE;AAAX,OAAzDI,EAFa,CAEbA;;AACAA,MAAAA,QAAQ,CAARA,gBAAAA,CAAAA,UAAAA,EAAsCT,KAAI,CAA1CS,aAAAA;;UACID,CAAC,CAADA,OAAAA,CAAAA,MAAAA,KAAJ,C,EAA4B;AAC1BR,QAAAA,KAAI,CAAJA,YAAAA,CAAAA,CAAAA;AADF,O,MAEO,IAAIQ,CAAC,CAADA,OAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAA4B;AACjCR,QAAAA,KAAI,CAAJA,WAAAA,CAAiBP,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAAvCR,CAAuCQ,CAAtBf,CAAjBO;;AAPJA,KAAAA;;AAWAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,UAAA,CAAA,EAAA;;AAEZQ,MAAAA,CAAC,CAADA,cAAAA;;UACIA,CAAC,CAADA,OAAAA,CAAAA,MAAAA,KAAJ,C,EAA4B;AAC1BR,QAAAA,KAAI,CAAJA,WAAAA,CAAAA,CAAAA;AADF,O,MAEO,IAAIQ,CAAC,CAADA,OAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAA4B;AACjCR,QAAAA,KAAI,CAAJA,MAAAA,CAAYP,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAAlCR,CAAkCQ,CAAtBf,CAAZO;;AANJA,KAAAA;;AAUAA,IAAAA,KAAAA,CAAAA,WAAAA,GAAc,UAAA,EAAA,EAAA;UAAGvD,CAAAA,GAAAA,EAAAA,CAAAA,C;UAAGE,CAAAA,GAAAA,EAAAA,CAAAA,C;;;;AAClBqD,MAAAA,KAAI,CAAJA,iBAAAA,GAAyB;AAAEvD,QAAAA,CAAC,EAAH,CAAA;AAAKE,QAAAA,CAAC,EAAA;AAAN,OAAzBqD;AACAA,MAAAA,KAAI,CAAJA,aAAAA,GAAAA,QAAAA,CAAAA,EAAAA,EAA0BA,KAAI,CAAJA,KAAAA,CAA1BA,IAAAA,CAAAA;YACA,CAAA,EAAA,GAAA,KAAI,CAAJ,KAAA,EAAA,kB,MAAA,I,IAAA,EAAA,KAAA,KAAA,C,GAAA,KAAA,C,GAAA,EAAA,CAAA,IAAA,CAAA,EAAA,C;AAHFA,KAAAA;;AAMAA,IAAAA,KAAAA,CAAAA,MAAAA,GAAS,UAAA,EAAA,EAAA;UAAGvD,CAAAA,GAAAA,EAAAA,CAAAA,C;UAAGE,CAAAA,GAAAA,EAAAA,CAAAA,C;UACTqD,KAAI,CAAR,c,EAAyBI,MAAM,CAANA,oBAAAA,CAA4BJ,KAAI,CAAhCI,cAAAA;AAEzBJ,MAAAA,KAAI,CAAJA,cAAAA,GAAsB,MAAM,CAAN,qBAAA,CAA6B,YAAA;YAC7C,CAACA,KAAI,CAAJA,KAAAA,CAAL,Q,EAA0B;YACtBvD,CAAC,KAADA,SAAAA,IAAmBE,CAAC,KAAxB,S,EAAwC;YAClCsE,OAAO,GAAGxE,CAAC,GAAGuD,KAAI,CAAJA,iBAAAA,CAApB,C;YACMkB,OAAO,GAAGvE,CAAC,GAAGqD,KAAI,CAAJA,iBAAAA,CAApB,C;YACMmB,iBAAiB,GAAG;AACxB1E,UAAAA,CAAC,EAAEuD,KAAI,CAAJA,aAAAA,CAAAA,CAAAA,GADqB,OAAA;AAExBrD,UAAAA,CAAC,EAAEqD,KAAI,CAAJA,aAAAA,CAAAA,CAAAA,GAAuBkB;AAFF,S;YAKpBE,WAAW,GAAGpB,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,GAChB3D,gBAAgB,CAAA,iBAAA,EAEd2D,KAAI,CAFU,SAAA,EAGdA,KAAI,CAAJA,KAAAA,CAHc,QAAA,EAIdA,KAAI,CAAJA,KAAAA,CAJc,IAAA,EAKdA,KAAI,CAAJA,KAAAA,CANcA,QACA,CADAA,GAApB,iB;;AASAA,QAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAAAA,WAAAA;AAnBFA,OAAsB,CAAtBA;AAHFA,KAAAA;;AA0BAA,IAAAA,KAAAA,CAAAA,aAAAA,GAAgB,YAAA;;;AACdA,MAAAA,KAAI,CAAJA,WAAAA;;AACAA,MAAAA,KAAI,CAAJA,YAAAA;;YACA,CAAA,EAAA,GAAA,KAAI,CAAJ,KAAA,EAAA,gB,MAAA,I,IAAA,EAAA,KAAA,KAAA,C,GAAA,KAAA,C,GAAA,EAAA,CAAA,IAAA,CAAA,EAAA,C;AAHFA,KAAAA;;AAkCAA,IAAAA,KAAAA,CAAAA,OAAAA,GAAU,UAAA,CAAA,EAAA;AACRQ,MAAAA,CAAC,CAADA,cAAAA;UACMiB,KAAK,GAAGhC,OAAO,CAAPA,aAAAA,CAAd,CAAcA,C;UACR8B,OAAO,GAAGvB,KAAI,CAAJA,KAAAA,CAAAA,IAAAA,GAAmBQ,CAAC,CAADA,MAAAA,GAAWR,KAAI,CAAJA,KAAAA,CAAZ,SAACQ,GAAnC,G;;AACAR,MAAAA,KAAI,CAAJA,UAAAA,CAAAA,OAAAA,EAAAA,KAAAA;;UAEI,CAACA,KAAI,CAAJA,KAAAA,CAAL,mB,EAAqC;AACnCA,QAAAA,KAAI,CAAJA,QAAAA,CAAc;AAAEG,UAAAA,mBAAmB,EAAE;AAAvB,SAAdH,EAA6C,YAAA;;;uBAAM,CAAA,EAAA,GAAA,KAAI,CAAJ,KAAA,EAAW0B,kB,MAAAA,I,IAAAA,EAAAA,KAAAA,KAAAA,C,GAAAA,KAAAA,C,GAAAA,EAAAA,CAAAA,IAAAA,CAAAA,EAAAA,C;AAA9D1B,SAAAA;;;UAGEA,KAAI,CAAR,U,EAAqB;AACnBM,QAAAA,YAAY,CAACN,KAAI,CAAjBM,UAAY,CAAZA;;;AAEFN,MAAAA,KAAI,CAAJA,UAAAA,GAAkB,MAAM,CAAN,UAAA,CAChB,YAAA;eAAM,KAAI,CAAJ,QAAA,CAAc;AAAEG,UAAAA,mBAAmB,EAAE;AAAvB,SAAd,EAA8C,YAAA;;;uBAAM,CAAA,EAAA,GAAA,KAAI,CAAJ,KAAA,EAAWwB,gB,MAAAA,I,IAAAA,EAAAA,KAAAA,KAAAA,C,GAAAA,KAAAA,C,GAAAA,EAAAA,CAAAA,IAAAA,CAAAA,EAAAA,C;AAA/D,SAAA,C;AADU,OAAA,EAAlB3B,GAAkB,CAAlBA;AAbFA,KAAAA;;AAmBAA,IAAAA,KAAAA,CAAAA,mBAAAA,GAAsB,UAAA,EAAA,EAAA;UAAGvD,CAAAA,GAAAA,EAAAA,CAAAA,C;UAAGE,CAAAA,GAAAA,EAAAA,CAAAA,C;;UACtB,CAACqD,KAAI,CAAT,a,EAAyB;cACjB,IAAA,KAAA,CAAN,4BAAM,C;;;aAED;AACLvD,QAAAA,CAAC,EAAEuD,KAAI,CAAJA,aAAAA,CAAAA,KAAAA,GAAAA,CAAAA,IAAgCvD,CAAC,GAAGuD,KAAI,CAAJA,aAAAA,CADlC,IACFA,CADE;AAELrD,QAAAA,CAAC,EAAEqD,KAAI,CAAJA,aAAAA,CAAAA,MAAAA,GAAAA,CAAAA,IAAiCrD,CAAC,GAAGqD,KAAI,CAAJA,aAAAA,CAArCA,GAAAA;AAFE,O;AAJTA,KAAAA;;AAUAA,IAAAA,KAAAA,CAAAA,eAAAA,GAAkB,UAAA,EAAA,EAAA;UAAGvD,CAAAA,GAAAA,EAAAA,CAAAA,C;UAAGE,CAAAA,GAAAA,EAAAA,CAAAA,C;UAChBgE,EAAAA,GAAAA,KAAAA,CAAAA,K;UAAExD,IAAAA,GAAAA,EAAAA,CAAFwD,I;UAAQnE,IAAAA,GAAAA,EAAAA,CAARmE,I;aACC;AACLlE,QAAAA,CAAC,EAAE,CAACA,CAAC,GAAGU,IAAI,CAAT,CAAA,IADE,IAAA;AAELR,QAAAA,CAAC,EAAE,CAACA,CAAC,GAAGQ,IAAI,CAAT,CAAA,IAAeX;AAFb,O;AAFTwD,KAAAA;;AAQAA,IAAAA,KAAAA,CAAAA,UAAAA,GAAa,UAAA,IAAA,EAAA,KAAA,EAAA;UACP,CAACA,KAAI,CAAJA,KAAAA,CAAD,QAAA,IAAwB,CAACA,KAAI,CAAJA,KAAAA,CAA7B,Y,EAAsD;;UAEhD4B,SAAS,GAAG5B,KAAI,CAAJA,mBAAAA,CAAlB,KAAkBA,C;;UACZ6B,UAAU,GAAG7B,KAAI,CAAJA,eAAAA,CAAnB,SAAmBA,C;;UACbuB,OAAO,GAAG1E,IAAI,CAAJA,GAAAA,CAASmD,KAAI,CAAJA,KAAAA,CAATnD,OAAAA,EAA6BA,IAAI,CAAJA,GAAAA,CAAAA,IAAAA,EAAemD,KAAI,CAAJA,KAAAA,CAA5D,OAA6CnD,CAA7BA,C;UACVsE,iBAAiB,GAAG;AACxB1E,QAAAA,CAAC,EAAEoF,UAAU,CAAVA,CAAAA,GAAAA,OAAAA,GAAyBD,SAAS,CADb,CAAA;AAExBjF,QAAAA,CAAC,EAAEkF,UAAU,CAAVA,CAAAA,GAAAA,OAAAA,GAAyBD,SAAS,CAACjF;AAFd,O;UAIpByE,WAAW,GAAGpB,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,GAChB3D,gBAAgB,CAAA,iBAAA,EAEd2D,KAAI,CAFU,SAAA,EAGdA,KAAI,CAAJA,KAAAA,CAHc,QAAA,EAAA,OAAA,EAKdA,KAAI,CAAJA,KAAAA,CANcA,QACA,CADAA,GAApB,iB;;AAUAA,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAAAA,WAAAA;;AACAA,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAAAA,OAAAA;AArBFA,KAAAA;;AAwBAA,IAAAA,KAAAA,CAAAA,YAAAA,GAAe,YAAA;UACT,CAACA,KAAI,CAAJA,KAAAA,CAAL,Q,EAA0B,OADb,CACa;;UAEpB8B,kBAAkB,GAAG9B,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,GACvB3D,gBAAgB,CACd2D,KAAI,CAAJA,KAAAA,CADc,IAAA,EAEdA,KAAI,CAFU,SAAA,EAGdA,KAAI,CAAJA,KAAAA,CAHc,QAAA,EAIdA,KAAI,CAAJA,KAAAA,CAJc,IAAA,EAKdA,KAAI,CAAJA,KAAAA,CANqBA,QACP,CADOA,GAQvBA,KAAI,CAAJA,KAAAA,CARJ,I;;UASM9D,EAAAA,GAAAA,kBAAAA,CAAAA,kBAAAA,EAAAA,KAAAA,CAAAA,SAAAA,EAAAA,KAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,KAAAA,CAAAA,SAAAA,EAAAA,EAAAA,KAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,CAAAA,KAAAA,CAAAA,QAAAA,EAAAA,KAAAA,CAAAA,KAAAA,CAAAA,gBAAAA,C;UAAEmB,sBAAAA,GAAAA,EAAAA,CAAFnB,sB;UAA0BwB,iBAAAA,GAAAA,EAAAA,CAA1BxB,iB;;AASN8D,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,cAAAA,IACEA,KAAI,CAAJA,KAAAA,CAAAA,cAAAA,CAAAA,sBAAAA,EADFA,iBACEA,CADFA;AArBFA,KAAAA;;AAyBAA,IAAAA,KAAAA,CAAAA,qBAAAA,GAAwB,YAAA;UAClB,CAACA,KAAI,CAAJA,KAAAA,CAAL,Q,EAA0B;UAEpBoB,WAAW,GAAGpB,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,GAChB3D,gBAAgB,CACd2D,KAAI,CAAJA,KAAAA,CADc,IAAA,EAEdA,KAAI,CAFU,SAAA,EAGdA,KAAI,CAAJA,KAAAA,CAHc,QAAA,EAIdA,KAAI,CAAJA,KAAAA,CAJc,IAAA,EAKdA,KAAI,CAAJA,KAAAA,CANcA,QACA,CADAA,GAQhBA,KAAI,CAAJA,KAAAA,CARJ,I;;AASAA,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,YAAAA,CAAAA,WAAAA;;AACAA,MAAAA,KAAI,CAAJA,YAAAA;AAbFA,KAAAA;;;;;AA1SAP,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,iBAAAA,GAAAA,YAAAA;AACEW,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,QAAAA,EAAkC,KAAlCA,YAAAA;;QACI,KAAJ,Y,EAAuB;WACrB,Y,CAAA,gB,CAAA,O,EAA4C,KAA5C,O,EAA0D;AAAEC,QAAAA,OAAO,EAAE;AAAX,O;WAC1D,Y,CAAA,gB,CAAA,c,EAAmD,KAAnD,iB;WACA,Y,CAAA,gB,CAAA,e,EAAoD,KAApD,iB;KALJZ,C;;;QASM,KAAA,QAAA,IAAiB,KAAA,QAAA,CAArB,Q,EAA6C;WAC3C,W;;AAVJA,GAAAA;;AAcAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,oBAAAA,GAAAA,YAAAA;AACEW,IAAAA,MAAM,CAANA,mBAAAA,CAAAA,QAAAA,EAAqC,KAArCA,YAAAA;;QACI,KAAJ,Y,EAAuB;WACrB,Y,CAAA,mB,CAAA,O,EAA+C,KAA/C,O;WACA,Y,CAAA,mB,CAAA,c,EAAsD,KAAtD,iB;WACA,Y,CAAA,mB,CAAA,e,EAAuD,KAAvD,iB;;;SAEF,W;;QACI,KAAJ,U,EAAqB;AACnBE,MAAAA,YAAY,CAAC,KAAbA,UAAY,CAAZA;;AATJb,GAAAA;;AAaAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,kBAAAA,GAAAA,UAAAA,SAAAA,EAAAA;QACMc,SAAS,CAATA,QAAAA,KAAuB,KAAA,KAAA,CAA3B,Q,EAAgD;WAC9C,Y;WACA,qB;AAFF,K,MAGO,IAAIA,SAAS,CAATA,MAAAA,KAAqB,KAAA,KAAA,CAAzB,MAAA,EAA4C;WACjD,Y;AADK,KAAA,MAEA,IAAIA,SAAS,CAATA,IAAAA,KAAmB,KAAA,KAAA,CAAvB,IAAA,EAAwC;WAC7C,qB;;AAPJd,GAAAA;;AA+CAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,SAAAA,GAAAA,YAAAA;QACQvD,EAAAA,GAAAA,KAAAA,K;QAAEK,QAAAA,GAAAA,EAAAA,CAAFL,Q;QAAYF,MAAAA,GAAAA,EAAAA,CAAZE,M;;QACN,Q,EAAc;aACLK,QAAQ,CAARA,KAAAA,GAAiBA,QAAQ,CAAhC,M;;;WAEF,M;AALFkD,GAAAA;;AA8GAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,YAAAA,GAAAA,UAAAA,CAAAA,EAAAA;QACQ1C,MAAM,GAAG0C,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAArC,CAAqCA,CAAtBf,C;QACTzC,MAAM,GAAGyC,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAArC,CAAqCA,CAAtBf,C;SACf,iB,GAAyB3C,wBAAwB,CAAA,MAAA,EAAjD,MAAiD,C;SACjD,iB,GAAyBG,wBAAwB,CAAA,MAAA,EAAjD,MAAiD,C;SACjD,W,CAAiBgB,SAAS,CAAA,MAAA,EAA1B,MAA0B,C;AAL5BwB,GAAAA;;AAQAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,WAAAA,GAAAA,UAAAA,CAAAA,EAAAA;gBAAAA,I;;QACQ1C,MAAM,GAAG0C,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAArC,CAAqCA,CAAtBf,C;QACTzC,MAAM,GAAGyC,OAAO,CAAPA,aAAAA,CAAsBe,CAAC,CAADA,OAAAA,CAArC,CAAqCA,CAAtBf,C;QACT4B,MAAM,GAAGpD,SAAS,CAAA,MAAA,EAAxB,MAAwB,C;SACxB,M,CAAA,M;QAEI,KAAJ,e,EAA0BmC,MAAM,CAANA,oBAAAA,CAA4B,KAA5BA,eAAAA;SAC1B,e,GAAuB,MAAM,CAAN,qBAAA,CAA6B,YAAA;UAC5CkB,QAAQ,GAAGxE,wBAAwB,CAAA,MAAA,EAAzC,MAAyC,C;UACnCyE,OAAO,GAAGvB,KAAI,CAAJA,KAAAA,CAAAA,IAAAA,IAAmBsB,QAAQ,GAAGtB,KAAI,CAAlD,iBAAgBA,C;;AAChBA,MAAAA,KAAI,CAAJA,UAAAA,CAAAA,OAAAA,EAAAA,MAAAA;;AACAA,MAAAA,KAAI,CAAJA,iBAAAA,GAAAA,QAAAA;UAEM/D,QAAQ,GAAGgB,wBAAwB,CAAA,MAAA,EAAzC,MAAyC,C;UACnCuE,WAAW,GAAGxB,KAAI,CAAJA,KAAAA,CAAAA,QAAAA,IAAuB/D,QAAQ,GAAG+D,KAAI,CAA1D,iBAAoBA,C;AACpBA,MAAAA,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,IAA+BA,KAAI,CAAJA,KAAAA,CAAAA,gBAAAA,CAA/BA,WAA+BA,CAA/BA;AACAA,MAAAA,KAAI,CAAJA,iBAAAA,GAAAA,QAAAA;AATF,KAAuB,C;AAPzBP,GAAAA;;AA0HAA,EAAAA,OAAAA,CAAAA,SAAAA,CAAAA,MAAAA,GAAAA,YAAAA;gBAAAA,I;;QACQvD,EAAAA,GAAAA,KAAAA,K;QACJ6F,KAAAA,GAAAA,EAAAA,CADI7F,K;QAEJ8F,KAAAA,GAAAA,EAAAA,CAFI9F,K;QAGJ4D,UAAAA,GAAAA,EAAAA,CAHI5D,U;QAIJyE,EAAAA,GAAAA,EAAAA,CAJIzE,I;QAIIO,CAAAA,GAAAA,EAAAA,CAJJP,C;QAIOS,CAAAA,GAAAA,EAAAA,CAJPT,C;QAKJD,QAAAA,GAAAA,EAAAA,CALIC,Q;QAMJM,IAAAA,GAAAA,EAAAA,CANIN,I;QAOJP,SAAAA,GAAAA,EAAAA,CAPIO,S;QAQJN,QAAAA,GAAAA,EAAAA,CARIM,Q;QASJ+F,EAAAA,GAAAA,EAAAA,CATI/F,K;QASKgG,cAAAA,GAAAA,EAAAA,CATLhG,c;QASqBiG,aAAAA,GAAAA,EAAAA,CATrBjG,a;QASoCkG,UAAAA,GAAAA,EAAAA,CATpClG,U;QAUJmG,EAAAA,GAAAA,EAAAA,CAVInG,O;QAUOoG,kBAAAA,GAAAA,EAAAA,CAVPpG,kB;QAU2BqG,iBAAAA,GAAAA,EAAAA,CAV3BrG,iB;QAU8CsG,cAAAA,GAAAA,EAAAA,CAV9CtG,c;WAcJ,KAAA,CAAA,aAAA,CAAA,SAAA,EAAA;AACEuG,MAAAA,WAAW,EAAE,KAAKA,WADpB;AAEEC,MAAAA,YAAY,EAAE,KAAKA,YAFrB;AAGEC,MAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,EAAA,EAAA;eAAO3C,KAAI,CAAJA,YAAAA,GAAD,E;OAHb;qBAIc,WAJd;AAKEJ,MAAAA,KAAK,EAAEsC,cALT;AAMEU,MAAAA,SAAS,EAAEN;AANb,KAAA,EAQGP,KAAK,GACJ,KAAA,CAAA,aAAA,CAAA,GAAA,EAAA,QAAA,CAAA;AACEc,MAAAA,GAAG,EAAC,EADN;AAEED,MAAAA,SAAS,EAAEJ;AAFb,KAAA,EAGM1C,UAHN,EAGMA;AACJgD,MAAAA,GAAG,EAAEf,KADDjC;AAEJ6C,MAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,EAAA,EAAA;eAA2B3C,KAAI,CAAJA,QAAAA,GAAD,E;OAF3BF;AAGJF,MAAAA,KAAK,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACAwC,UADA,CAAA,EACAA;AACHpH,QAAAA,SAAS,EAAE,eAAA,CAAA,GAAA,MAAA,GAAA,CAAA,GAAA,aAAA,GAAA,QAAA,GAAA,aAAA,GAAA,IAAA,GAAA;AADRoH,OADA,CAHDtC;AAOJiD,MAAAA,MAAM,EAAE,KAAKC;AAPTlD,KAHN,CAAA,CADI,GAcJkC,KAAK,IACH,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACEiB,MAAAA,QAAQ,EAAA,IADV;AAEEC,MAAAA,IAAI,EAAA,IAFN;AAGEC,MAAAA,KAAK,EAAE,IAHT;AAIEN,MAAAA,GAAG,EAAC,EAJN;AAKED,MAAAA,SAAS,EAAEJ;AALb,KAAA,EAMM1C,UANN,EAMMA;AACJgD,MAAAA,GAAG,EAAEd,KADDlC;AAEJ6C,MAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,EAAA,EAAA;eAA2B3C,KAAI,CAAJA,QAAAA,GAAD,E;OAF3BF;AAGJsD,MAAAA,gBAAgB,EAAE,KAAKJ,WAHnBlD;AAIJF,MAAAA,KAAK,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACAwC,UADA,CAAA,EACAA;AACHpH,QAAAA,SAAS,EAAE,eAAA,CAAA,GAAA,MAAA,GAAA,CAAA,GAAA,aAAA,GAAA,QAAA,GAAA,aAAA,GAAA,IAAA,GAAA;AADRoH,OADA,CAJDtC;AAQJuD,MAAAA,QAAQ,EAAE;AARNvD,KANN,CAAA,CAvBN,EAyCG,KAAA,KAAA,CAAA,QAAA,IACC,KAAA,CAAA,aAAA,CAAA,QAAA,EAAA;AACEnE,MAAAA,SAAS,EAAEA,SADb;AAEEC,MAAAA,QAAQ,EAAEA,QAFZ;AAGEgE,MAAAA,KAAK,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACAuC,aADA,CAAA,EACAA;AACHhG,QAAAA,KAAK,EAAE,KAAA,KAAA,CAAA,QAAA,CAAoBA,KADxBgG;AAEH/F,QAAAA,MAAM,EAAE,KAAA,KAAA,CAAA,QAAA,CAAoBA;AAFzB+F,OADA,CAHP;qBAQc,SARd;AASES,MAAAA,SAAS,EAAEL;AATb,KAAA,CA1CJ,C;AAfJ9C,GAAAA;;AA3VOA,EAAAA,OAAAA,CAAAA,YAAAA,GAAe;AACpBjD,IAAAA,IAAI,EADgB,CAAA;AAEpBP,IAAAA,QAAQ,EAFY,CAAA;AAGpBD,IAAAA,MAAM,EAAE,IAHY,CAAA;AAIpB0D,IAAAA,OAAO,EAJa,QAAA;AAKpBC,IAAAA,OAAO,EALa,QAAA;AAMpBhE,IAAAA,SAAS,EANW,MAAA;AAOpBC,IAAAA,QAAQ,EAPY,IAAA;AAQpBgE,IAAAA,KAAK,EARe,EAAA;AASpBC,IAAAA,OAAO,EATa,EAAA;AAUpBC,IAAAA,UAAU,EAVU,EAAA;AAWpBC,IAAAA,SAAS,EAXW,CAAA;AAYpB1D,IAAAA,gBAAgB,EAAE;AAZE,GAAfoD;;AA2IAA,EAAAA,OAAAA,CAAAA,aAAAA,GAAgB,UAAA,CAAA,EAAA;WAAuC;AAC5DhD,MAAAA,CAAC,EAAEsE,MAAM,CAACP,CAAC,CADiD,OACnD,CADmD;AAE5D7D,MAAAA,CAAC,EAAEoE,MAAM,CAACP,CAAC,CAAF,OAAA;AAFmD,K;AAAvDf,GAAAA;;AAKAA,EAAAA,OAAAA,CAAAA,aAAAA,GAAgB,UAAA,KAAA,EAAA;WAAiC;AACtDhD,MAAAA,CAAC,EAAEsE,MAAM,CAACC,KAAK,CADuC,OAC7C,CAD6C;AAEtDrE,MAAAA,CAAC,EAAEoE,MAAM,CAACC,KAAK,CAAN,OAAA;AAF6C,K;AAAjDvB,GAAAA;;SAmRT,O;EApasBD,KAAK,CAA3B,S,CAAA","sourcesContent":["import styled from '@emotion/styled'\n\nexport const Container = styled('div')({\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  overflow: 'hidden',\n  userSelect: 'none',\n  touchAction: 'none',\n  cursor: 'move',\n})\n\nconst mediaStyles = {\n  maxWidth: '100%',\n  maxHeight: '100%',\n  margin: 'auto',\n  position: 'absolute',\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  willChange: 'transform', // this improves performances and prevent painting issues on iOS Chrome\n}\n\n// @ts-ignore I don't want to duplicate mediaStyles\nexport const Img = styled('img')(mediaStyles)\n// @ts-ignore I don't want to duplicate mediaStyles\nexport const Video = styled('video')(mediaStyles)\n\nconst lineBorder = '1px solid rgba(255, 255, 255, 0.5)'\nconst cropperLines = {\n  content: '\" \"',\n  boxSizing: 'border-box',\n  position: 'absolute',\n  border: lineBorder,\n}\nconst cropperArea = {\n  position: 'absolute',\n  left: '50%',\n  top: '50%',\n  transform: 'translate(-50%, -50%)',\n  border: lineBorder,\n  boxSizing: 'border-box',\n  boxShadow: '0 0 0 9999em',\n  color: 'rgba(0,0,0,0.5)',\n  overflow: 'hidden',\n}\nconst gridLines = {\n  '&::before': {\n    ...cropperLines,\n    top: 0,\n    bottom: 0,\n    left: '33.33%',\n    right: '33.33%',\n    borderTop: 0,\n    borderBottom: 0,\n  },\n  '&::after': {\n    ...cropperLines,\n    top: '33.33%',\n    bottom: '33.33%',\n    left: 0,\n    right: 0,\n    borderLeft: 0,\n    borderRight: 0,\n  },\n}\nconst roundShape = {\n  borderRadius: '50%',\n}\n\ntype CropAreaProps = {\n  cropShape: 'round' | 'rect'\n  showGrid: boolean\n}\n\n// @ts-ignore styled definition does not accept an empty object as first param, while it actually works\nexport const CropArea = styled('div')({}, ({ cropShape, showGrid }: CropAreaProps) => ({\n  ...(() => {\n    switch (cropShape) {\n      case 'round':\n        return { ...cropperArea, ...roundShape }\n      case 'rect':\n      default:\n        return cropperArea\n    }\n  })(),\n  ...(showGrid ? gridLines : {}),\n}))\n","import { Area, MediaSize, Point, Size } from './types'\n\n/**\n * Compute the dimension of the crop area based on media size,\n * aspect ratio and optionally rotatation\n */\nexport function getCropSize(\n  mediaWidth: number,\n  mediaHeight: number,\n  aspect: number,\n  rotation = 0\n): Size {\n  const { width, height } = translateSize(mediaWidth, mediaHeight, rotation)\n\n  if (mediaWidth >= mediaHeight * aspect && width > mediaHeight * aspect) {\n    return {\n      width: mediaHeight * aspect,\n      height: mediaHeight,\n    }\n  }\n\n  if (width > mediaHeight * aspect) {\n    return {\n      width: mediaWidth,\n      height: mediaWidth / aspect,\n    }\n  }\n\n  if (width > height * aspect) {\n    return {\n      width: height * aspect,\n      height: height,\n    }\n  }\n\n  return {\n    width: width,\n    height: width / aspect,\n  }\n}\n\n/**\n * Ensure a new media position stays in the crop area.\n */\nexport function restrictPosition(\n  position: Point,\n  mediaSize: Size,\n  cropSize: Size,\n  zoom: number,\n  rotation = 0\n): Point {\n  const { width, height } = translateSize(mediaSize.width, mediaSize.height, rotation)\n\n  return {\n    x: restrictPositionCoord(position.x, width, cropSize.width, zoom),\n    y: restrictPositionCoord(position.y, height, cropSize.height, zoom),\n  }\n}\n\nfunction restrictPositionCoord(\n  position: number,\n  mediaSize: number,\n  cropSize: number,\n  zoom: number\n): number {\n  const maxPosition = (mediaSize * zoom) / 2 - cropSize / 2\n  return Math.min(maxPosition, Math.max(position, -maxPosition))\n}\n\nexport function getDistanceBetweenPoints(pointA: Point, pointB: Point) {\n  return Math.sqrt(Math.pow(pointA.y - pointB.y, 2) + Math.pow(pointA.x - pointB.x, 2))\n}\n\nexport function getRotationBetweenPoints(pointA: Point, pointB: Point) {\n  return (Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180) / Math.PI\n}\n\n/**\n * Compute the output cropped area of the media in percentages and pixels.\n * x/y are the top-left coordinates on the src media\n */\nexport function computeCroppedArea(\n  crop: Point,\n  mediaSize: MediaSize,\n  cropSize: Size,\n  aspect: number,\n  zoom: number,\n  rotation = 0,\n  restrictPosition = true\n): { croppedAreaPercentages: Area; croppedAreaPixels: Area } {\n  // if the media is rotated by the user, we cannot limit the position anymore\n  // as it might need to be negative.\n  const limitAreaFn = restrictPosition && rotation === 0 ? limitArea : noOp\n  const croppedAreaPercentages = {\n    x: limitAreaFn(\n      100,\n      (((mediaSize.width - cropSize.width / zoom) / 2 - crop.x / zoom) / mediaSize.width) * 100\n    ),\n    y: limitAreaFn(\n      100,\n      (((mediaSize.height - cropSize.height / zoom) / 2 - crop.y / zoom) / mediaSize.height) * 100\n    ),\n    width: limitAreaFn(100, ((cropSize.width / mediaSize.width) * 100) / zoom),\n    height: limitAreaFn(100, ((cropSize.height / mediaSize.height) * 100) / zoom),\n  }\n\n  // we compute the pixels size naively\n  const widthInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalWidth,\n      (croppedAreaPercentages.width * mediaSize.naturalWidth) / 100\n    )\n  )\n  const heightInPixels = Math.round(\n    limitAreaFn(\n      mediaSize.naturalHeight,\n      (croppedAreaPercentages.height * mediaSize.naturalHeight) / 100\n    )\n  )\n  const isImgWiderThanHigh = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n\n  // then we ensure the width and height exactly match the aspect (to avoid rounding approximations)\n  // if the media is wider than high, when zoom is 0, the crop height will be equals to iamge height\n  // thus we want to compute the width from the height and aspect for accuracy.\n  // Otherwise, we compute the height from width and aspect.\n  const sizePixels = isImgWiderThanHigh\n    ? {\n        width: Math.round(heightInPixels * aspect),\n        height: heightInPixels,\n      }\n    : {\n        width: widthInPixels,\n        height: Math.round(widthInPixels / aspect),\n      }\n  const croppedAreaPixels = {\n    ...sizePixels,\n    x: Math.round(\n      limitAreaFn(\n        mediaSize.naturalWidth - sizePixels.width,\n        (croppedAreaPercentages.x * mediaSize.naturalWidth) / 100\n      )\n    ),\n    y: Math.round(\n      limitAreaFn(\n        mediaSize.naturalHeight - sizePixels.height,\n        (croppedAreaPercentages.y * mediaSize.naturalHeight) / 100\n      )\n    ),\n  }\n  return { croppedAreaPercentages, croppedAreaPixels }\n}\n\n/**\n * Ensure the returned value is between 0 and max\n */\nfunction limitArea(max: number, value: number): number {\n  return Math.min(max, Math.max(0, value))\n}\n\nfunction noOp(_max: number, value: number) {\n  return value\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nfunction getZoomFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): number {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  if (cropSize) {\n    const isHeightMaxSize = cropSize.height > cropSize.width\n    return isHeightMaxSize\n      ? cropSize.height / mediaZoom / croppedAreaPixels.height\n      : cropSize.width / mediaZoom / croppedAreaPixels.width\n  }\n\n  const aspect = croppedAreaPixels.width / croppedAreaPixels.height\n  const isHeightMaxSize = mediaSize.naturalWidth >= mediaSize.naturalHeight * aspect\n  return isHeightMaxSize\n    ? mediaSize.naturalHeight / croppedAreaPixels.height\n    : mediaSize.naturalWidth / croppedAreaPixels.width\n}\n\n/**\n * Compute the crop and zoom from the croppedAreaPixels\n */\nexport function getInitialCropFromCroppedAreaPixels(\n  croppedAreaPixels: Area,\n  mediaSize: MediaSize,\n  cropSize?: Size\n): { crop: Point; zoom: number } {\n  const mediaZoom = mediaSize.width / mediaSize.naturalWidth\n\n  const zoom = getZoomFromCroppedAreaPixels(croppedAreaPixels, mediaSize, cropSize)\n\n  const cropZoom = mediaZoom * zoom\n\n  const crop = {\n    x: ((mediaSize.naturalWidth - croppedAreaPixels.width) / 2 - croppedAreaPixels.x) * cropZoom,\n    y: ((mediaSize.naturalHeight - croppedAreaPixels.height) / 2 - croppedAreaPixels.y) * cropZoom,\n  }\n  return { crop, zoom }\n}\n\n/**\n * Return the point that is the center of point a and b\n */\nexport function getCenter(a: Point, b: Point): Point {\n  return {\n    x: (b.x + a.x) / 2,\n    y: (b.y + a.y) / 2,\n  }\n}\n\n/**\n *\n * Returns an x,y point once rotated around xMid,yMid\n */\nexport function rotateAroundMidPoint(\n  x: number,\n  y: number,\n  xMid: number,\n  yMid: number,\n  degrees: number\n): [number, number] {\n  const cos = Math.cos\n  const sin = Math.sin\n  const radian = (degrees * Math.PI) / 180 // Convert to radians\n  // Subtract midpoints, so that midpoint is translated to origin\n  // and add it in the end again\n  const xr = (x - xMid) * cos(radian) - (y - yMid) * sin(radian) + xMid\n  const yr = (x - xMid) * sin(radian) + (y - yMid) * cos(radian) + yMid\n\n  return [xr, yr]\n}\n\n/**\n * Returns the new bounding area of a rotated rectangle.\n */\nexport function translateSize(width: number, height: number, rotation: number): Size {\n  const centerX = width / 2\n  const centerY = height / 2\n\n  const outerBounds = [\n    rotateAroundMidPoint(0, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, 0, centerX, centerY, rotation),\n    rotateAroundMidPoint(width, height, centerX, centerY, rotation),\n    rotateAroundMidPoint(0, height, centerX, centerY, rotation),\n  ]\n\n  const minX = Math.min(...outerBounds.map(p => p[0]))\n  const maxX = Math.max(...outerBounds.map(p => p[0]))\n  const minY = Math.min(...outerBounds.map(p => p[1]))\n  const maxY = Math.max(...outerBounds.map(p => p[1]))\n\n  return { width: maxX - minX, height: maxY - minY }\n}\n","import React from 'react'\nimport { Container, CropArea, Img, Video } from './styles'\nimport { Area, MediaSize, Point, Size } from './types'\nimport {\n  getCropSize,\n  restrictPosition,\n  getDistanceBetweenPoints,\n  getRotationBetweenPoints,\n  computeCroppedArea,\n  getCenter,\n  getInitialCropFromCroppedAreaPixels,\n} from './helpers'\n\ntype Props = {\n  image?: string\n  video?: string\n  crop: Point\n  zoom: number\n  rotation: number\n  aspect: number\n  minZoom: number\n  maxZoom: number\n  cropShape: 'rect' | 'round'\n  cropSize?: Size\n  showGrid?: boolean\n  zoomSpeed: number\n  onCropChange: (location: Point) => void\n  onZoomChange?: (zoom: number) => void\n  onRotationChange?: (rotation: number) => void\n  onCropComplete?: (croppedArea: Area, croppedAreaPixels: Area) => void\n  onInteractionStart?: () => void\n  onInteractionEnd?: () => void\n  onMediaLoaded?: (mediaSize: MediaSize) => void\n  style: {\n    containerStyle?: React.CSSProperties\n    mediaStyle?: React.CSSProperties\n    cropAreaStyle?: React.CSSProperties\n  }\n  classes: {\n    containerClassName?: string\n    mediaClassName?: string\n    cropAreaClassName?: string\n  }\n  restrictPosition: boolean\n  initialCroppedAreaPixels?: Area\n  mediaProps: React.ImgHTMLAttributes<HTMLElement> | React.VideoHTMLAttributes<HTMLElement>\n}\n\ntype State = {\n  cropSize: Size | null\n  hasWheelJustStarted: boolean\n}\n\nconst MIN_ZOOM = 1\nconst MAX_ZOOM = 3\n\nclass Cropper extends React.Component<Props, State> {\n  static defaultProps = {\n    zoom: 1,\n    rotation: 0,\n    aspect: 4 / 3,\n    maxZoom: MAX_ZOOM,\n    minZoom: MIN_ZOOM,\n    cropShape: 'rect',\n    showGrid: true,\n    style: {},\n    classes: {},\n    mediaProps: {},\n    zoomSpeed: 1,\n    restrictPosition: true,\n  }\n\n  imageRef: HTMLImageElement | null = null\n  videoRef: HTMLVideoElement | null = null\n  containerRef: HTMLDivElement | null = null\n  containerRect: DOMRect | null = null\n  mediaSize: MediaSize = { width: 0, height: 0, naturalWidth: 0, naturalHeight: 0 }\n  dragStartPosition: Point = { x: 0, y: 0 }\n  dragStartCrop: Point = { x: 0, y: 0 }\n  lastPinchDistance = 0\n  lastPinchRotation = 0\n  rafDragTimeout: number | null = null\n  rafPinchTimeout: number | null = null\n  wheelTimer: number | null = null\n\n  state: State = {\n    cropSize: null,\n    hasWheelJustStarted: false,\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.addEventListener('wheel', this.onWheel, { passive: false })\n      this.containerRef.addEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.addEventListener('gesturechange', this.preventZoomSafari)\n    }\n\n    // when rendered via SSR, the image can already be loaded and its onLoad callback will never be called\n    if (this.imageRef && this.imageRef.complete) {\n      this.onMediaLoad()\n    }\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.computeSizes)\n    if (this.containerRef) {\n      this.containerRef.removeEventListener('wheel', this.onWheel)\n      this.containerRef.removeEventListener('gesturestart', this.preventZoomSafari)\n      this.containerRef.removeEventListener('gesturechange', this.preventZoomSafari)\n    }\n    this.cleanEvents()\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.rotation !== this.props.rotation) {\n      this.computeSizes()\n      this.recomputeCropPosition()\n    } else if (prevProps.aspect !== this.props.aspect) {\n      this.computeSizes()\n    } else if (prevProps.zoom !== this.props.zoom) {\n      this.recomputeCropPosition()\n    }\n  }\n\n  // this is to prevent Safari on iOS >= 10 to zoom the page\n  preventZoomSafari = (e: Event) => e.preventDefault()\n\n  cleanEvents = () => {\n    document.removeEventListener('mousemove', this.onMouseMove)\n    document.removeEventListener('mouseup', this.onDragStopped)\n    document.removeEventListener('touchmove', this.onTouchMove)\n    document.removeEventListener('touchend', this.onDragStopped)\n  }\n\n  onMediaLoad = () => {\n    this.computeSizes()\n    this.emitCropData()\n    this.setInitialCrop()\n\n    if (this.props.onMediaLoaded) {\n      this.props.onMediaLoaded(this.mediaSize)\n    }\n  }\n\n  setInitialCrop = () => {\n    const { initialCroppedAreaPixels, cropSize } = this.props\n\n    if (!initialCroppedAreaPixels) {\n      return\n    }\n\n    const { crop, zoom } = getInitialCropFromCroppedAreaPixels(\n      initialCroppedAreaPixels,\n      this.mediaSize,\n      cropSize\n    )\n    this.props.onCropChange(crop)\n    this.props.onZoomChange && this.props.onZoomChange(zoom)\n  }\n\n  getAspect() {\n    const { cropSize, aspect } = this.props\n    if (cropSize) {\n      return cropSize.width / cropSize.height\n    }\n    return aspect\n  }\n\n  computeSizes = () => {\n    const mediaRef = this.imageRef || this.videoRef\n    if (mediaRef) {\n      this.mediaSize = {\n        width: mediaRef.offsetWidth,\n        height: mediaRef.offsetHeight,\n        naturalWidth: this.imageRef?.naturalWidth || this.videoRef?.videoWidth || 0,\n        naturalHeight: this.imageRef?.naturalHeight || this.videoRef?.videoHeight || 0,\n      }\n      const cropSize = this.props.cropSize\n        ? this.props.cropSize\n        : getCropSize(\n            mediaRef.offsetWidth,\n            mediaRef.offsetHeight,\n            this.props.aspect,\n            this.props.rotation\n          )\n      this.setState({ cropSize }, this.recomputeCropPosition)\n    }\n    if (this.containerRef) {\n      this.containerRect = this.containerRef.getBoundingClientRect()\n    }\n  }\n\n  static getMousePoint = (e: MouseEvent | React.MouseEvent) => ({\n    x: Number(e.clientX),\n    y: Number(e.clientY),\n  })\n\n  static getTouchPoint = (touch: Touch | React.Touch) => ({\n    x: Number(touch.clientX),\n    y: Number(touch.clientY),\n  })\n\n  onMouseDown = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    e.preventDefault()\n    document.addEventListener('mousemove', this.onMouseMove)\n    document.addEventListener('mouseup', this.onDragStopped)\n    this.onDragStart(Cropper.getMousePoint(e))\n  }\n\n  onMouseMove = (e: MouseEvent) => this.onDrag(Cropper.getMousePoint(e))\n\n  onTouchStart = (e: React.TouchEvent<HTMLDivElement>) => {\n    e.preventDefault()\n    document.addEventListener('touchmove', this.onTouchMove, { passive: false }) // iOS 11 now defaults to passive: true\n    document.addEventListener('touchend', this.onDragStopped)\n    if (e.touches.length === 2) {\n      this.onPinchStart(e)\n    } else if (e.touches.length === 1) {\n      this.onDragStart(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onTouchMove = (e: TouchEvent) => {\n    // Prevent whole page from scrolling on iOS.\n    e.preventDefault()\n    if (e.touches.length === 2) {\n      this.onPinchMove(e)\n    } else if (e.touches.length === 1) {\n      this.onDrag(Cropper.getTouchPoint(e.touches[0]))\n    }\n  }\n\n  onDragStart = ({ x, y }: Point) => {\n    this.dragStartPosition = { x, y }\n    this.dragStartCrop = { ...this.props.crop }\n    this.props.onInteractionStart?.()\n  }\n\n  onDrag = ({ x, y }: Point) => {\n    if (this.rafDragTimeout) window.cancelAnimationFrame(this.rafDragTimeout)\n\n    this.rafDragTimeout = window.requestAnimationFrame(() => {\n      if (!this.state.cropSize) return\n      if (x === undefined || y === undefined) return\n      const offsetX = x - this.dragStartPosition.x\n      const offsetY = y - this.dragStartPosition.y\n      const requestedPosition = {\n        x: this.dragStartCrop.x + offsetX,\n        y: this.dragStartCrop.y + offsetY,\n      }\n\n      const newPosition = this.props.restrictPosition\n        ? restrictPosition(\n            requestedPosition,\n            this.mediaSize,\n            this.state.cropSize,\n            this.props.zoom,\n            this.props.rotation\n          )\n        : requestedPosition\n      this.props.onCropChange(newPosition)\n    })\n  }\n\n  onDragStopped = () => {\n    this.cleanEvents()\n    this.emitCropData()\n    this.props.onInteractionEnd?.()\n  }\n\n  onPinchStart(e: React.TouchEvent<HTMLDivElement>) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    this.lastPinchDistance = getDistanceBetweenPoints(pointA, pointB)\n    this.lastPinchRotation = getRotationBetweenPoints(pointA, pointB)\n    this.onDragStart(getCenter(pointA, pointB))\n  }\n\n  onPinchMove(e: TouchEvent) {\n    const pointA = Cropper.getTouchPoint(e.touches[0])\n    const pointB = Cropper.getTouchPoint(e.touches[1])\n    const center = getCenter(pointA, pointB)\n    this.onDrag(center)\n\n    if (this.rafPinchTimeout) window.cancelAnimationFrame(this.rafPinchTimeout)\n    this.rafPinchTimeout = window.requestAnimationFrame(() => {\n      const distance = getDistanceBetweenPoints(pointA, pointB)\n      const newZoom = this.props.zoom * (distance / this.lastPinchDistance)\n      this.setNewZoom(newZoom, center)\n      this.lastPinchDistance = distance\n\n      const rotation = getRotationBetweenPoints(pointA, pointB)\n      const newRotation = this.props.rotation + (rotation - this.lastPinchRotation)\n      this.props.onRotationChange && this.props.onRotationChange(newRotation)\n      this.lastPinchRotation = rotation\n    })\n  }\n\n  onWheel = (e: WheelEvent) => {\n    e.preventDefault()\n    const point = Cropper.getMousePoint(e)\n    const newZoom = this.props.zoom - (e.deltaY * this.props.zoomSpeed) / 200\n    this.setNewZoom(newZoom, point)\n\n    if (!this.state.hasWheelJustStarted) {\n      this.setState({ hasWheelJustStarted: true }, () => this.props.onInteractionStart?.())\n    }\n\n    if (this.wheelTimer) {\n      clearTimeout(this.wheelTimer)\n    }\n    this.wheelTimer = window.setTimeout(\n      () => this.setState({ hasWheelJustStarted: false }, () => this.props.onInteractionEnd?.()),\n      250\n    )\n  }\n\n  getPointOnContainer = ({ x, y }: Point) => {\n    if (!this.containerRect) {\n      throw new Error('The Cropper is not mounted')\n    }\n    return {\n      x: this.containerRect.width / 2 - (x - this.containerRect.left),\n      y: this.containerRect.height / 2 - (y - this.containerRect.top),\n    }\n  }\n\n  getPointOnMedia = ({ x, y }: Point) => {\n    const { crop, zoom } = this.props\n    return {\n      x: (x + crop.x) / zoom,\n      y: (y + crop.y) / zoom,\n    }\n  }\n\n  setNewZoom = (zoom: number, point: Point) => {\n    if (!this.state.cropSize || !this.props.onZoomChange) return\n\n    const zoomPoint = this.getPointOnContainer(point)\n    const zoomTarget = this.getPointOnMedia(zoomPoint)\n    const newZoom = Math.min(this.props.maxZoom, Math.max(zoom, this.props.minZoom))\n    const requestedPosition = {\n      x: zoomTarget.x * newZoom - zoomPoint.x,\n      y: zoomTarget.y * newZoom - zoomPoint.y,\n    }\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          requestedPosition,\n          this.mediaSize,\n          this.state.cropSize,\n          newZoom,\n          this.props.rotation\n        )\n      : requestedPosition\n\n    this.props.onCropChange(newPosition)\n    this.props.onZoomChange(newZoom)\n  }\n\n  emitCropData = () => {\n    if (!this.state.cropSize) return\n    // this is to ensure the crop is correctly restricted after a zoom back (https://github.com/ricardo-ch/react-easy-crop/issues/6)\n    const restrictedPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    const { croppedAreaPercentages, croppedAreaPixels } = computeCroppedArea(\n      restrictedPosition,\n      this.mediaSize,\n      this.state.cropSize,\n      this.getAspect(),\n      this.props.zoom,\n      this.props.rotation,\n      this.props.restrictPosition\n    )\n    this.props.onCropComplete &&\n      this.props.onCropComplete(croppedAreaPercentages, croppedAreaPixels)\n  }\n\n  recomputeCropPosition = () => {\n    if (!this.state.cropSize) return\n\n    const newPosition = this.props.restrictPosition\n      ? restrictPosition(\n          this.props.crop,\n          this.mediaSize,\n          this.state.cropSize,\n          this.props.zoom,\n          this.props.rotation\n        )\n      : this.props.crop\n    this.props.onCropChange(newPosition)\n    this.emitCropData()\n  }\n\n  render() {\n    const {\n      image,\n      video,\n      mediaProps,\n      crop: { x, y },\n      rotation,\n      zoom,\n      cropShape,\n      showGrid,\n      style: { containerStyle, cropAreaStyle, mediaStyle },\n      classes: { containerClassName, cropAreaClassName, mediaClassName },\n    } = this.props\n\n    return (\n      <Container\n        onMouseDown={this.onMouseDown}\n        onTouchStart={this.onTouchStart}\n        ref={el => (this.containerRef = el)}\n        data-testid=\"container\"\n        style={containerStyle}\n        className={containerClassName}\n      >\n        {image ? (\n          <Img\n            alt=\"\"\n            className={mediaClassName}\n            {...mediaProps}\n            src={image}\n            ref={(el: HTMLImageElement) => (this.imageRef = el)}\n            style={{\n              ...mediaStyle,\n              transform: `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n            }}\n            onLoad={this.onMediaLoad}\n          />\n        ) : (\n          video && (\n            <Video\n              autoPlay\n              loop\n              muted={true}\n              alt=\"\"\n              className={mediaClassName}\n              {...mediaProps}\n              src={video}\n              ref={(el: HTMLVideoElement) => (this.videoRef = el)}\n              onLoadedMetadata={this.onMediaLoad}\n              style={{\n                ...mediaStyle,\n                transform: `translate(${x}px, ${y}px) rotate(${rotation}deg) scale(${zoom})`,\n              }}\n              controls={false}\n            />\n          )\n        )}\n        {this.state.cropSize && (\n          <CropArea\n            cropShape={cropShape}\n            showGrid={showGrid}\n            style={{\n              ...cropAreaStyle,\n              width: this.state.cropSize.width,\n              height: this.state.cropSize.height,\n            }}\n            data-testid=\"cropper\"\n            className={cropAreaClassName}\n          />\n        )}\n      </Container>\n    )\n  }\n}\n\nexport default Cropper\n"]},"metadata":{},"sourceType":"module"}