{"ast":null,"code":"import _regeneratorRuntime from\"C:\\\\Users\\\\shahar\\\\Desktop\\\\webS\\\\MyProjacts\\\\ChatPet\\\\client-side\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";var createImage=function createImage(url){return new Promise(function(resolve,reject){var image=new Image();image.addEventListener('load',function(){return resolve(image);});image.addEventListener('error',function(error){return reject(error);});image.setAttribute('crossOrigin','anonymous');// needed to avoid cross-origin issues on CodeSandbox\nimage.src=url;});};function getRadianAngle(degreeValue){return degreeValue*Math.PI/180;}export default function getCroppedImg(imageSrc,pixelCrop){var rotation,image,canvas,ctx,safeArea,data,_args=arguments;return _regeneratorRuntime.async(function getCroppedImg$(_context){while(1){switch(_context.prev=_context.next){case 0:rotation=_args.length>2&&_args[2]!==undefined?_args[2]:0;_context.next=3;return _regeneratorRuntime.awrap(createImage(imageSrc));case 3:image=_context.sent;canvas=document.createElement('canvas');ctx=canvas.getContext('2d');safeArea=Math.max(image.width,image.height)*2;// set each dimensions to double largest dimension to allow for a safe area for the\n// image to rotate in without being clipped by canvas context\ncanvas.width=safeArea;canvas.height=safeArea;// translate canvas context to a central location on image to allow rotating around the center.\nctx.translate(safeArea/2,safeArea/2);ctx.rotate(getRadianAngle(rotation));ctx.translate(-safeArea/2,-safeArea/2);// draw rotated image and store data.\nctx.drawImage(image,safeArea/2-image.width*0.5,safeArea/2-image.height*0.5);data=ctx.getImageData(0,0,safeArea,safeArea);// set canvas width to final desired crop size - this will clear existing context\ncanvas.width=pixelCrop.width;canvas.height=pixelCrop.height;// paste generated rotate image with correct offsets for x,y crop values.\nctx.putImageData(data,0-safeArea/2+image.width*0.5-pixelCrop.x,0-safeArea/2+image.height*0.5-pixelCrop.y);// As Base64 string\nreturn _context.abrupt(\"return\",canvas.toDataURL('image/jpeg'));case 18:case\"end\":return _context.stop();}}});}","map":{"version":3,"sources":["C:/Users/shahar/Desktop/webS/MyProjacts/ChatPet/client-side/src/components/imageSetting/cropImage.js"],"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","getRadianAngle","degreeValue","Math","PI","getCroppedImg","imageSrc","pixelCrop","rotation","canvas","document","createElement","ctx","getContext","safeArea","max","width","height","translate","rotate","drawImage","data","getImageData","putImageData","x","y","toDataURL"],"mappings":"qLAAA,GAAMA,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAAAC,GAAG,QACrB,IAAIC,CAAAA,OAAJ,CAAY,SAACC,OAAD,CAAUC,MAAV,CAAqB,CAC/B,GAAMC,CAAAA,KAAK,CAAG,GAAIC,CAAAA,KAAJ,EAAd,CACAD,KAAK,CAACE,gBAAN,CAAuB,MAAvB,CAA+B,iBAAMJ,CAAAA,OAAO,CAACE,KAAD,CAAb,EAA/B,EACAA,KAAK,CAACE,gBAAN,CAAuB,OAAvB,CAAgC,SAAAC,KAAK,QAAIJ,CAAAA,MAAM,CAACI,KAAD,CAAV,EAArC,EACAH,KAAK,CAACI,YAAN,CAAmB,aAAnB,CAAkC,WAAlC,EAA+C;AAC/CJ,KAAK,CAACK,GAAN,CAAYT,GAAZ,CACD,CAND,CADqB,EAAvB,CASA,QAASU,CAAAA,cAAT,CAAwBC,WAAxB,CAAqC,CACnC,MAAQA,CAAAA,WAAW,CAAGC,IAAI,CAACC,EAApB,CAA0B,GAAjC,CACD,CAED,cAAe,SAAeC,CAAAA,aAAf,CAA6BC,QAA7B,CAAuCC,SAAvC,qLAAkDC,QAAlD,+CAA6D,CAA7D,kDACOlB,WAAW,CAACgB,QAAD,CADlB,SACPX,KADO,eAEPc,MAFO,CAEEC,QAAQ,CAACC,aAAT,CAAuB,QAAvB,CAFF,CAGPC,GAHO,CAGDH,MAAM,CAACI,UAAP,CAAkB,IAAlB,CAHC,CAKPC,QALO,CAKIX,IAAI,CAACY,GAAL,CAASpB,KAAK,CAACqB,KAAf,CAAsBrB,KAAK,CAACsB,MAA5B,EAAsC,CAL1C,CAOb;AACA;AACAR,MAAM,CAACO,KAAP,CAAeF,QAAf,CACAL,MAAM,CAACQ,MAAP,CAAgBH,QAAhB,CAEA;AACAF,GAAG,CAACM,SAAJ,CAAcJ,QAAQ,CAAG,CAAzB,CAA4BA,QAAQ,CAAG,CAAvC,EACAF,GAAG,CAACO,MAAJ,CAAWlB,cAAc,CAACO,QAAD,CAAzB,EACAI,GAAG,CAACM,SAAJ,CAAc,CAACJ,QAAD,CAAY,CAA1B,CAA6B,CAACA,QAAD,CAAY,CAAzC,EAEA;AACAF,GAAG,CAACQ,SAAJ,CACEzB,KADF,CAEEmB,QAAQ,CAAG,CAAX,CAAenB,KAAK,CAACqB,KAAN,CAAc,GAF/B,CAGEF,QAAQ,CAAG,CAAX,CAAenB,KAAK,CAACsB,MAAN,CAAe,GAHhC,EAKMI,IAvBO,CAuBAT,GAAG,CAACU,YAAJ,CAAiB,CAAjB,CAAoB,CAApB,CAAuBR,QAAvB,CAAiCA,QAAjC,CAvBA,CAyBb;AACAL,MAAM,CAACO,KAAP,CAAeT,SAAS,CAACS,KAAzB,CACAP,MAAM,CAACQ,MAAP,CAAgBV,SAAS,CAACU,MAA1B,CAEA;AACAL,GAAG,CAACW,YAAJ,CACEF,IADF,CAEE,EAAIP,QAAQ,CAAG,CAAf,CAAmBnB,KAAK,CAACqB,KAAN,CAAc,GAAjC,CAAuCT,SAAS,CAACiB,CAFnD,CAGE,EAAIV,QAAQ,CAAG,CAAf,CAAmBnB,KAAK,CAACsB,MAAN,CAAe,GAAlC,CAAwCV,SAAS,CAACkB,CAHpD,EAMA;AApCa,gCAqCNhB,MAAM,CAACiB,SAAP,CAAiB,YAAjB,CArCM","sourcesContent":["const createImage = url =>\r\n  new Promise((resolve, reject) => {\r\n    const image = new Image()\r\n    image.addEventListener('load', () => resolve(image))\r\n    image.addEventListener('error', error => reject(error))\r\n    image.setAttribute('crossOrigin', 'anonymous') // needed to avoid cross-origin issues on CodeSandbox\r\n    image.src = url\r\n  })\r\n\r\nfunction getRadianAngle(degreeValue) {\r\n  return (degreeValue * Math.PI) / 180\r\n}\r\n\r\nexport default async function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\r\n  const image = await createImage(imageSrc)\r\n  const canvas = document.createElement('canvas')\r\n  const ctx = canvas.getContext('2d')\r\n\r\n  const safeArea = Math.max(image.width, image.height) * 2\r\n\r\n  // set each dimensions to double largest dimension to allow for a safe area for the\r\n  // image to rotate in without being clipped by canvas context\r\n  canvas.width = safeArea\r\n  canvas.height = safeArea\r\n\r\n  // translate canvas context to a central location on image to allow rotating around the center.\r\n  ctx.translate(safeArea / 2, safeArea / 2)\r\n  ctx.rotate(getRadianAngle(rotation))\r\n  ctx.translate(-safeArea / 2, -safeArea / 2)\r\n\r\n  // draw rotated image and store data.\r\n  ctx.drawImage(\r\n    image,\r\n    safeArea / 2 - image.width * 0.5,\r\n    safeArea / 2 - image.height * 0.5\r\n  )\r\n  const data = ctx.getImageData(0, 0, safeArea, safeArea)\r\n\r\n  // set canvas width to final desired crop size - this will clear existing context\r\n  canvas.width = pixelCrop.width\r\n  canvas.height = pixelCrop.height\r\n\r\n  // paste generated rotate image with correct offsets for x,y crop values.\r\n  ctx.putImageData(\r\n    data,\r\n    0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x,\r\n    0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y\r\n  )\r\n\r\n  // As Base64 string\r\n  return canvas.toDataURL('image/jpeg')\r\n\r\n  // As a blob\r\n//   return new Promise(resolve => {\r\n//     canvas.toBlob(file => {\r\n//       resolve(URL.createObjectURL(file))\r\n//     }, 'image/jpeg')\r\n//   })\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}