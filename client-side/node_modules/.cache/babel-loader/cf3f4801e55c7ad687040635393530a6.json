{"ast":null,"code":"const createImage = url => {\n  new Promise((resolve, reject) => {\n    const image = new Image();\n    image.addEventListener('load', () => resolve(image));\n    image.addEventListener('error', error => reject(error));\n    image.setAttribute('crossOrigin', 'anonymous'); // needed to avoid cross-origin issues on CodeSandbox\n\n    image.src = url;\n    console.log(image + ' 1');\n  });\n};\n\nfunction getRadianAngle(degreeValue) {\n  return degreeValue * Math.PI / 180;\n}\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n * @param {File} image - Image File url\r\n * @param {Object} pixelCrop - pixelCrop Object provided by react-easy-crop\r\n * @param {number} rotation - optional rotation parameter\r\n */\n\n\nexport default async function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\n  console.log(imageSrc);\n  const image = createImage(imageSrc);\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  console.log(image);\n  const safeArea = Math.max(image.width, image.height) * 2; // set each dimensions to double largest dimension to allow for a safe area for the\n  // image to rotate in without being clipped by canvas context\n\n  canvas.width = safeArea;\n  canvas.height = safeArea; // translate canvas context to a central location on image to allow rotating around the center.\n\n  ctx.translate(safeArea / 2, safeArea / 2);\n  ctx.rotate(getRadianAngle(rotation));\n  ctx.translate(-safeArea / 2, -safeArea / 2); // draw rotated image and store data.\n\n  ctx.drawImage(image, safeArea / 2 - image.width * 0.5, safeArea / 2 - image.height * 0.5);\n  const data = ctx.getImageData(0, 0, safeArea, safeArea); // set canvas width to final desired crop size - this will clear existing context\n\n  canvas.width = pixelCrop.width;\n  canvas.height = pixelCrop.height; // paste generated rotate image with correct offsets for x,y crop values.\n\n  ctx.putImageData(data, 0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x, 0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y); // As Base64 string\n  // return canvas.toDataURL('image/jpeg');\n  // As a blob\n\n  return new Promise(resolve => {\n    canvas.toBlob(file => {\n      resolve(URL.createObjectURL(file));\n    }, 'image/jpeg');\n  });\n}","map":{"version":3,"sources":["C:/Users/shahar/Desktop/webS/MyProjacts/ChatPet/client-side/src/cropImage.js"],"names":["createImage","url","Promise","resolve","reject","image","Image","addEventListener","error","setAttribute","src","console","log","getRadianAngle","degreeValue","Math","PI","getCroppedImg","imageSrc","pixelCrop","rotation","canvas","document","createElement","ctx","getContext","safeArea","max","width","height","translate","rotate","drawImage","data","getImageData","putImageData","x","y","toBlob","file","URL","createObjectURL"],"mappings":"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","sourcesContent":["const createImage = url =>{\r\n  new Promise((resolve, reject) => {\r\n    const image = new Image()\r\n    image.addEventListener('load', () => resolve(image))\r\n    image.addEventListener('error', error => reject(error))\r\n    image.setAttribute('crossOrigin', 'anonymous') // needed to avoid cross-origin issues on CodeSandbox\r\n    image.src = url\r\n    console.log(image+ ' 1')\r\n  })\r\n\r\n}\r\n\r\nfunction getRadianAngle(degreeValue) {\r\n  return (degreeValue * Math.PI) / 180\r\n}\r\n\r\n/**\r\n * This function was adapted from the one in the ReadMe of https://github.com/DominicTobias/react-image-crop\r\n * @param {File} image - Image File url\r\n * @param {Object} pixelCrop - pixelCrop Object provided by react-easy-crop\r\n * @param {number} rotation - optional rotation parameter\r\n */\r\nexport default async function getCroppedImg(imageSrc, pixelCrop, rotation = 0) {\r\n console.log(imageSrc)\r\n  const image = createImage(imageSrc)\r\n  const canvas = document.createElement('canvas')\r\n  const ctx = canvas.getContext('2d')\r\nconsole.log(image)\r\n  const safeArea = Math.max(image.width, image.height) * 2\r\n\r\n  // set each dimensions to double largest dimension to allow for a safe area for the\r\n  // image to rotate in without being clipped by canvas context\r\n  canvas.width = safeArea\r\n  canvas.height = safeArea\r\n\r\n  // translate canvas context to a central location on image to allow rotating around the center.\r\n  ctx.translate(safeArea / 2, safeArea / 2)\r\n  ctx.rotate(getRadianAngle(rotation))\r\n  ctx.translate(-safeArea / 2, -safeArea / 2)\r\n\r\n  // draw rotated image and store data.\r\n  ctx.drawImage(\r\n    image,\r\n    safeArea / 2 - image.width * 0.5,\r\n    safeArea / 2 - image.height * 0.5\r\n  )\r\n  const data = ctx.getImageData(0, 0, safeArea, safeArea)\r\n\r\n  // set canvas width to final desired crop size - this will clear existing context\r\n  canvas.width = pixelCrop.width\r\n  canvas.height = pixelCrop.height\r\n\r\n  // paste generated rotate image with correct offsets for x,y crop values.\r\n  ctx.putImageData(\r\n    data,\r\n    0 - safeArea / 2 + image.width * 0.5 - pixelCrop.x,\r\n    0 - safeArea / 2 + image.height * 0.5 - pixelCrop.y\r\n  )\r\n\r\n  // As Base64 string\r\n  // return canvas.toDataURL('image/jpeg');\r\n\r\n  // As a blob\r\n  return new Promise(resolve => {\r\n    canvas.toBlob(file => {\r\n      resolve(URL.createObjectURL(file))\r\n    }, 'image/jpeg')\r\n  })\r\n}\r\n"]},"metadata":{},"sourceType":"module"}